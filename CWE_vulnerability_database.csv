CWE-ID,Name,Threat Model,Sample Assets,Security Objective,Technical Impact
CWE-1209,Failure to Disable Reserved Bits Before Publishing Hardware Design,"In hardware designs, reserved bits in control or configuration registers are typically intended for future functionality and should be disabled or ignored in production. If these bits remain active, they may enable undocumented logic or hidden modes when written toóeither unintentionally or by an attacker. Attackers can reverse-engineer these reserved fields to alter system behavior, trigger debug states, or bypass protectionsóespecially if these bits influence security-critical functions like secure boot or memory access control. Moreover, if documentation labels fields as ""reserved"" or ""for future use,"" this may signal to an attacker that the bits might unlock latent or undocumented functionality, making them an attractive target.","1. A simple register interface with a reserved bit that is not masked or ignored.
2. A Random Access Memory (RAM) module with a reserved address range that responds to read/write operations.
3. An ALU with 7 defined and 1 reserved instruction, where the reserved instruction triggers undocumented behavior.
4. A DMA controller with undocumented config bits that affect address remapping.
5. An interrupt controller with reserved priority fields that, when written to, alter scheduling behavior.
6. A bootloader with reserved config bits that disable integrity checks.
7. A power management unit where reserved bits trigger test modes when manipulated.
8. A system timer with undocumented modes enabled by writing to reserved fields.","Confidentiality, Integrity, Availability, Access Control, Accountability, Authentication, Authorization, Non-Repudiation","Unauthorized access, Security bypass, Unintended behavior, Loss of integrity or availability"
CWE-1221,Incorrect Register Defaults or Module Parameters,"In hardware designs, registers and module parameters define critical system configurations and behaviors. Incorrectly setting default values for these registers or parameters can lead to insecure states upon power-up or reset. Such misconfigurations may inadvertently grant untrusted software components elevated privileges or expose sensitive operations, thereby increasing the system's vulnerability to exploitation. Since these defaults are often hardcoded in the hardware description language (HDL), rectifying them post-production is challenging and may necessitate hardware revisions. If insecure defaults are exposed in documentation or remain unchanged during system integration, attackers can leverage them as entry points.","1. System-on-Chip (SoC) where security-related registers disable protections by default.
2. Peripheral device with open access control by default.
3. Processor with debug interface enabled by default.
4. Memory controller with weak default access permissions.
5. Communication module (e.g., a network interface card (NIC)) with encryption disabled by default.","Confidentiality, Integrity, Availability, Access Control","Degradation of system functionality, Loss of access control enforcement"
CWE-1223,Race Condition for Write-Once Attributes,"In hardware designs, write-once registers are intended to be configured a single time, typically during system initialization by trusted software components. A race condition arises when an untrusted or lower-privileged component gains the opportunity to write to these registers before the trusted component, leading to unauthorized configuration and potential security vulnerabilities. This can occur in systems where multiple software modules operate concurrently, and the hardware does not enforce strict access controls on the sequence of register writes. Exploiting this race condition can result in improper system configurations, undermining intended security policies and system integrity.","1. System-on-Chip (SoC) where trusted and untrusted firmware modules execute concurrently, allowing the untrusted one to write to security-critical write-once registers first.
2. Peripheral device with write-once configuration registers that are accessible to both privileged and unprivileged software.
3. Shared memory controller configured by multiple processors after reset, with a risk that untrusted code configures it before trusted initialization.","Access Control, Authorization","Bypassing protection mechanisms, Unauthorized configuration, Privilege escalation"
CWE-1224,Improper Restriction of Write-Once Bit Fields,"In hardware designs, certain control registers are implemented as write-once or 'sticky' to ensure critical configurations are securely initialized and remain unchanged during runtime. If the hardware fails to enforce write-once behavior correctly, untrusted software may reprogram these fields, compromising system security. For instance, a design that only enforces protection after a field is set to '1' may function as 'write-1-once', allowing unintended changes to '0' or other states. This exposes the system to unauthorized access or reconfiguration.","1. SoC with security configuration registers that can be reprogrammed due to weak write-once enforcement.
2. Peripheral device with control registers rewriteable post-initialization.
3. Memory controller using sticky bits for access control that can be modified later.
4. Processor debug interface enabled via a write-once register that can be toggled.
5. Cryptographic module with boot-time-only configuration registers that can be altered.","Confidentiality, Integrity, Availability, Access Control","Unauthorized access, Security misconfiguration, Data corruption, System instability"
CWE-1231,Improper Prevention of Lock Bit Modification,"In hardware designs, lock bits are used to secure critical configuration registers and prevent their modification after system initialization. If the design allows the lock bit to be altered after being set, this opens the door for unauthorized entities to unlock and reconfigure sensitive hardware settings. Such vulnerabilities can undermine the protection mechanism, exposing the system to privilege escalation, misconfiguration, or security bypass.","1. SoC configuration registers protected by a lock bit that can be cleared post-initialization.
2. Memory controller where access control registers are modifiable after clearing the lock bit.
3. Peripheral device with security settings locked by a bit that can be toggled by untrusted software.",Access Control,"Protected configuration can be modified, leading to unauthorized access or control."
CWE-1232,Improper Lock Behavior After Power State Transition,"This vulnerability arises when register lock bit protectionsóintended to prevent unauthorized modifications to critical configuration registersódo not persist across power state transitions (e.g., reset, sleep, or hibernate). In many System-on-Chip (SoC) designs, trusted firmware (e.g., BIOS or bootloader) configures key registers and sets lock bits during boot. However, after a power transition, these protections may be unintentionally cleared, leaving registers temporarily unlocked or reset to insecure defaults.
This brief window allows attackers to modify sensitive configuration registers (e.g., memory controllers, crypto engines, memory-mapped I/O (MMIO) access policies) before the locks are re-established, potentially leading to privilege escalation, data leakage, or system disruption. For example, during resume from hibernation, DRAM controller settings may be left unprotected until firmware reinitializes the locks. Similarly, buggy RTL may incorrectly reset lock registers, exposing critical assets. Exploiting this vulnerability typically requires software execution capability during or just after the transitionóbefore the lock protections are restored.","1. Configuration Registers: Store security-critical settings like boot modes, crypto policies, or MMIO regions.
2. Lock Registers and Lock Bits: Mechanisms used to restrict updates to configuration registers after boot.
3. Memory Controllers (e.g., DRAM controller): Control access to memory regions; vulnerable if registers are temporarily modifiable.
4. Cryptographic Engine Configuration Registers: Define operational parameters and access control for hardware crypto modules.
5. Power Management Controller (PMC): Manages sleep/resume transitions and may be responsible for restoring lock states.
6. Memory-Mapped I/O (MMIO) Permission Registers: Define access policies for peripherals and secure regions.",Access Control,"Unauthorized modification of protected configurations, privilege escalation, disruption of secure system state"
CWE-1233,Security-Sensitive Hardware Controls with Missing Lock Bit Protection,"CWE-1233 describes a vulnerability where security-sensitive hardware controls lack any form of lock bit protection. This means that after the initial configuration, there is no mechanism to prevent unauthorized or malicious modification of critical settings at runtime. Unlike CWE-1231 ó which refers to a faulty implementation of a lock bit ó CWE-1233 highlights the complete absence of protection. Both can lead to similar consequences, such as unauthorized access to debug interfaces, disabling of memory protection, or reconfiguring boot settings.","1. SoC with configuration registers lacking lock bits.
2. MPU with no lock bit on access control registers.
3. Peripheral control registers modifiable post-boot.
4. Clock configuration registers without lock protection.
5. Voltage regulator settings open to modification.",Access Control,"Unauthorized modification of system configuration, Privilege escalation, Hardware instability"
CWE-1234,Hardware Internal or Debug Modes Allow Override of Locks,"In hardware systems, lock bits are used to prevent modifications to critical registers post-configuration. If debug, scan, or internal test modes allow these locks to be bypassed, it opens the system to unauthorized changes. Even if lock bits are set, the presence of undocumented or unsecured override paths can lead to serious security breaches by exposing sensitive settings or disabling protections.","1. SoC allowing locked configuration registers to be modified in debug mode.
2. Microcontroller with scan mode that overrides lock bits.
3. Peripheral devices with internal test modes bypassing register locks.
4. Processors with undocumented debug unlock sequences that disable protections.
5. Memory controllers permitting locked region changes in maintenance mode.",Access Control,"Bypass of protections, Unauthorized configuration modification"
CWE-1245,Improper Finite State Machines (FSMs) in Hardware Logic,"In hardware designs, Finite State Machines (FSMs) are critical for managing the sequential behavior of circuits. Faulty FSM implementationsósuch as incomplete state transitions, undefined states, or improper handling of unexpected inputsócan lead the system into unstable or unintended states. Attackers may exploit these vulnerabilities to cause denial of service (DoS), escalate privileges, or disrupt critical functionality.

A key threat arises from illegal access paths to states, which can occur when FSMs deviate from their behavioral specifications. These deviations can be introduced unintentionally by synthesis tools, which may fill in  ìdonít careîù conditions with incorrect transitions or states during optimization, or by malicious actions such as hardware Trojans. An attacker can exploit these illegal paths by crafting specific input sequences that trigger unintended state transitions, potentially bypassing security checks or gaining unauthorized access to protected states. For example, in an FSM designed to verify a password, an attacker could exploit unspecified conditions or rogue changes to transition to a protected state without valid credentials.

In addition to design flaws, attackers may also use fault injection techniques to force the FSM into unintended states by manipulating operating conditions like clock frequency, voltage, or temperature. These methods can cause the FSM to capture incorrect states, enabling bypass of security mechanisms or causing system crashes.","1. Communication Protocol Controllers: A network interface controller (e.g., UART, SPI, I≤C, USB) with an FSM that fails to handle unexpected packet sequences or device states, potentially leading to deadlock, denial of service (DoS), or unintended privilege escalation.

2. Power Management Units: FSMs in power controllers that mishandle state transitions during sleep, reset, or power mode changes, causing the system to skip necessary security handshakes or enter unsafe voltage/current configurations.

3. Cryptographic Modules: FSMs controlling encryption key loading or mode switching that can be driven into undefined or error states through crafted input sequences, potentially leaking key material or skipping validation steps.

4. Password or Challenge-Response FSMs: A combinational or sequential FSM for password verification or secure unlocking that can be bypassed due to missing state validations or synthesis-filled ""don't care"" transitions.

5. Processor Pipeline Control Logic: FSMs governing instruction execution or pipeline hazard control, which may allow invalid transitions (e.g., speculative execution in undefined conditions), leading to side-channel leakage or erratic program behavior.

Secure Boot Controllers: FSMs controlling boot sequence verification that can be glitched or reset into skipping signature checks or integrity verification stages.

Peripheral Controllers: FSMs in USB, Ethernet, or other peripheral modules that incorrectly handle error or reset states, potentially allowing malformed requests to crash the controller or trigger undefined behavior.

Cache Coherence / Memory Access FSMs: FSMs handling memory arbitration or cache coherence protocols (e.g., MESI) that fail under rare concurrent access patterns or fault injection, potentially leading to privilege violations or data races.","Availability, Access Control","Unauthorized state transitions

Bypass of authentication or boot sequences

Denial of service via FSM lock-up

Leakage of sensitive information

Unintended execution or control flow"
CWE-1250,Improper Preservation of Consistency Between Independent Representations of Shared State,"In hardware systems, especially those involving parallel execution, distributed control, or multi-core architectures, multiple components may maintain local copies of shared state; such as FSM state encodings, cache contents, or Memory Management Unit (MMU) mappings. When these representations become inconsistent due to improper synchronization or lack of coherence enforcement, the system can enter unsafe or unpredictable states.

For example, FSMs replicated across clock domains may transition based on desynchronized state inputs, leading to unauthorized control flows or functional breakdowns. In multicore processors, cache controllers may operate on stale data if cache coherence protocols fail to properly propagate updates or invalidations, compromising data integrity. Likewise, inconsistencies between MMU page tables and per-core TLBs (Translation Lookaside Buffers) can enable unauthorized memory access or cause execution faults. These issues are especially dangerous in security-critical environments, where stale or mismatched state views can be exploited to bypass protection mechanisms, escalate privileges, or induce denial-of-service.","1. FSMs Across Clock Domains: Control logic replicated across domains without proper synchronization.
2. Multicore Cache Systems: Shared memory architectures with incomplete cache coherence enforcement.
3. MMU and Per-Core TLBs: Inconsistent updates to memory mappings across processor cores.
4. Accelerators with Shadow Registers: Local register caching without mechanisms for coherence or invalidation.","Integrity, Availability, Authorization","Data inconsistency, Unauthorized access or actions, System instability or crashes, Violation of memory protection, Unintended control flow execution"
CWE-1253,Incorrect Selection of Fuse Values,"In hardware design, fuses are often employed to store critical data, including security configurations. Typically, an unblown fuse represents a logic 0, while a blown fuse signifies a logic 1. Fuses are generally considered one-directional; once blown to logic 1, they cannot be reset. If the system's security logic relies on a fuse remaining unblown (logic 0) to enforce a secure state, an attacker could blow the fuse to shift the system into an insecure state. This improper selection of fuse logic can lead to unauthorized access, privilege escalation, or disabling of security features.","1. Secure Boot Configuration: System requires fuse to remain unblown for secure boot; blowing it disables secure boot.
2. Debug Interface Access Control: Fuse restricts debug access when unblown; attacker blows it to enable debug.
3. Feature Enablement Controls: A fuse blow enables optional features; blowing a security-sensitive feature may weaken protection.","Access Control, Authorization","Bypassing protection mechanisms, Gaining unauthorized privileges, Disabling security features"
CWE-1254,Incorrect Comparison Logic Granularity,"In hardware designs, comparison logic is used to validate sensitive inputs such as passwords, Message Authentication Codes (MACs), or challenge-response data. When implemented with fine granularityóe.g., byte-by-byte comparisons that terminate early on mismatchóthis creates observable timing differences that attackers can exploit via side-channel attacks.

Over repeated attempts, attackers can use these timing variations to infer how many bytes matched before failure, allowing them to incrementally guess correct values. For example, in CVE-2014-0984, a password-checking function terminated early, enabling attackers to perform a timing-based brute-force attack. Such vulnerabilities can lead to unauthorized access and privilege escalation.","1. Password Verification Modules: Byte-by-byte comparison with early exit leaks match length through timing.
2. Cryptographic Authentication Units: Per-byte MAC comparison enables inference of correct bytes through response times.
3. Challenge-Response Authentication Systems: Timing differences during response validation reveal partial correct values.","Confidentiality, Authorization","Bypassing protection mechanisms, Unauthorized access, Privilege escalation, Leakage of secret values through timing side channels"
CWE-1261,Improper Handling of Single Event Upsets,"A Single Event Upset (SEU) is a temporary, non-destructive bit flip in digital logic or memory caused by external environmental factors. If hardware designs lack mechanisms to detect or correct such bit flips, attackers can exploit them to bypass security features, corrupt control logic, or escalate privileges. For example, a bit flip in a configuration register may disable access control, or in a finite state machine (FSM), force unauthorized transitions. Without validation or recovery from these transient faults, SEUs become a potential attack vector for triggering unauthorized access, data corruption, or denial of service.","1. Processors and Microcontrollers: SEUs in control/status registers may cause privilege escalation or execution redirection.
2. Memory Modules: Bit flips in access control bits or cryptographic keys may compromise system security.
3. Security Configuration Registers: Flipped bits may disable protections such as secure boot or MPU settings.
4. FSMs in Security Blocks: SEUs may trigger illegal states, bypassing access checks or state validation.
5. Crypto Engines: Bit flips in key registers or intermediate state can lead to incorrect encryption or leakage.","Access Control, Integrity, Availability, Authorization","Privilege escalation, unauthorized access, data corruption, denial of service"
CWE-1298,Hardware Logic Contains Race Conditions,"In hardware designs, race conditions occur when the output or behavior of a circuit depends on the timing of signal arrivals, often due to inputs propagating through unequal paths or unsynchronized domains. If a circuit's logic does not account for potential delays or overlaps in signal transitions, it can result in glitches, metastability, or incorrect evaluations. These race conditions can become exploitable in security-sensitive systems where timing-related errors affect access control, privilege enforcement, or system state transitions. An attacker may induce or exploit such conditions through crafted inputs, triggering unauthorized state changes, privilege escalation, or bypass of protection logic.","1. Access Control Logic: Timing errors may cause logic to incorrectly grant or deny access to protected memory or I/O regions.
2. Finite State Machines (FSMs): FSMs governing critical operations may enter unintended states due to race conditions.
3. Clock Domain Crossing Circuits: Improper synchronization between different clock domains can lead to data corruption.
4. Bus Arbitration Logic: Race conditions in bus arbitration may lead to multiple components assuming control simultaneously.
5. Interrupt Handling Mechanisms: Unsynchronized signals may cause missed or unintended interrupt servicing.
6. Cryptographic Modules: Timing issues may alter control paths and expose internal states.
7. Processor Control Units: Race conditions may cause incorrect control signal assertions or privilege changes.","Access Control, Integrity, Authorization","Unauthorized access, data corruption, privilege escalation, bypass of execution controls"
CWE-226,Sensitive Information in Resource Not Removed Before Reuse,"This vulnerability arises when a product releases a resource, such as memory or a file, without properly clearing or zeroizing the sensitive information contained within it. Consequently, when the resource is reused, unauthorized entities may access residual data, leading to potential exposure of confidential information. This issue is particularly critical during the final stage of a resource's lifecycle, such as deletion, expiration, or release for reuse.","1. Memory Buffers: If sensitive data stored in memory buffers is not cleared before deallocation, subsequent processes may access this data upon memory reuse.
2. Temporary Files: Applications creating temporary files containing sensitive information must ensure these files are securely deleted or sanitized before deletion.
3. Network Packets: Network devices that reuse packet buffers without clearing previous data may transmit sensitive information inadvertently.
4. Hardware Registers: Registers that hold sensitive data should be cleared before transitioning between operational states.",Confidentiality,Unauthorized access to sensitive data
CWE-1246,Improper Write Handling in Limited-write Non-Volatile Memories,"Non-volatile memories (NVMs) such as NAND Flash and EEPROM have a limited number of program/erase or write cycles per memory segment. To ensure uniform wear and prolong the lifespan of these memories, wear leveling techniques are employed. If a product fails to implement or incorrectly implements wear leveling, certain memory blocks may experience premature wear, leading to unreliability or failure. Attackers can exploit this weakness by inducing excessive writes to specific memory locations, causing targeted blocks to fail and potentially leading to system instability or denial of service.","1. Embedded Systems with Flash Storage: Improper wear leveling may cause configuration data loss.
2. Solid-State Drives (SSDs): Poor wear management reduces lifespan and data reliability.
3. Consumer Electronics: EEPROM wear issues can cause boot failures or system crashes.
4. Automotive Control Units: Premature wear in NVM may disrupt vehicle control functions.",Availability,"Denial of Service (DoS), System Instability"
CWE-1251,Mirrored Regions with Different Values,"In hardware architectures, mirrored regionsósuch as caches, registers, or memory segmentsóare duplicated to improve performance, redundancy, or fault tolerance. These regions must remain synchronized to ensure consistent system behavior. When synchronization mechanisms are flawed or bypassed, mismatches can occur, leading to inconsistent states and system vulnerabilities.

Attackers may exploit these inconsistencies by inducing or identifying conditions where mirrored components become unsynchronized. For example, carefully crafted memory access patterns, race conditions, or partial updates can result in one region holding stale or incorrect data. If security decisions rely on the outdated region, attackers may bypass access controls, corrupt data, or leak sensitive information.

More advanced attacks may involve fault injection, such as voltage glitches or clock manipulation, to disrupt synchronization logic. The success of such attacks depends on the attackerís ability to influence the timing or correctness of updates across mirrored regions, potentially compromising system integrity and reliability.","1. Processor Caches: Inconsistent data between L1 and L2 caches may lead to execution with stale or incorrect data.
2. Redundant Registers: Discrepancies between primary and backup registers may affect fault-tolerant operation.
3. Mirrored Memory Segments: Differences in mirrored memory can lead to data integrity issues and data loss.
4. Distributed Storage Systems: Inconsistent mirrored nodes can cause data retrieval errors or stale reads.                                                                                                                                                                                                                                                                                                                                                     5. Memory Management Units (MMUs): In multicore systems with shadow MMUs, delayed propagation of access-range updates can be exploited by attackers to access restricted memory during synchronization gaps.","Integrity, Confidentiality, Availability, Access Control, Accountability, Authentication, Authorization, Non-Repudiation","Data corruption, unauthorized data access, system instability"
CWE-1257,Improper Access Control Applied to Mirrored or Aliased Memory Regions,"In hardware designs, mirrored or aliased memory regions refer to multiple addresses that map to the same physical memory location. This approach is often used to simplify address decoding, improve compatibility, or support redundancy. However, if access control policies are not uniformly applied across all aliases of the same memory location, it can lead to severe security flaws. A restricted memory region may unintentionally be accessible through one of its aliases if proper permissions are not enforced consistently. Attackers can exploit this inconsistency to read or write sensitive data, bypass security restrictions, or elevate privileges.","1. System-on-Chip (SoC) Architectures: Memory regions mirrored for fault tolerance or redundancy might unintentionally expose secure areas to non-privileged agents.
2. Memory-Mapped I/O Devices: Hardware registers exposed at multiple addresses may be modified if inconsistent access control is enforced.
3. Embedded Systems with Memory Aliasing: Reused memory regions under different aliases may expose protected firmware if access rules differ.
4. Virtual Memory Systems: If page permissions vary between aliases, a lower-privileged process may access sensitive data.","Confidentiality, Integrity, Access Control, Authorization","Unauthorized data access, data modification, privilege escalation"
CWE-1282,Assumed-Immutable Data is Stored in Writable Memory,"This vulnerability occurs when critical security dataósuch as bootloaders, cryptographic keys, device IDs, or hash digestsóis stored in memory that can be modified. These values are trusted by hardware and firmware to make secure decisions during boot and access control. If they are writable, an attacker could change or replace them, breaking the trust model and enabling privilege escalation, device impersonation, or the execution of malicious code. For example, a device may store a golden hash digest to verify the integrity of boot code or public keys. If an attacker can overwrite this digest, they could insert malicious data that still passes integrity checks. To prevent such attacks, these values must be stored in immutable memory, preferably enforced by hardware.","1. First-Stage Bootloader: Writable bootloader may be altered to bypass secure boot or inject malicious code.
2. Cryptographic Keys (Public/Private): Writable key storage enables tampering or key replacement.
3. Golden Hash Digests: Altering reference hashes can let attackers validate unauthorized code.
4. Device Identifiers / Unique Hardware IDs: Writable IDs allow spoofing and unauthorized network access.
5. Write-Once Configuration Settings: Malicious changes may disable security policies or enforcement logic.",Integrity,"Unauthorized code execution, authentication bypass, device impersonation, loss of system trust"
CWE-1420,Exposure of Sensitive Information during Transient Execution,"This vulnerability occurs when a processor speculatively executes instructionsódue to events like branch mispredictions, exceptions, or microcode assistsóbefore confirming their validity. Although the results of these transient instructions are eventually discarded, they may leave microarchitectural side effects, such as changes in the CPU cache. These side effects can be measured by an attacker using side-channel techniques to infer sensitive information.
For example, an attacker might trigger speculative execution of a memory access that reads data outside of an allowed boundary. While the access is rolled back by the processor, it may affect the cache. By measuring timing differences during subsequent accesses, the attacker can deduce the leaked data.
Attackers can exploit this in two primary ways:
a. Writing their own code to intentionally trigger transient execution and leak data via a covert channel.
b. Identifying and abusing code paths in victim programs (such as mispredicted bounds checks) that execute transiently and expose sensitive information.
In addition to these cases, environments that use just-in-time (JIT) compilers or self-modifying code introduce further risk. The processor may transiently execute stale instructions (i.e., outdated code held in the pipeline or cache) before a store fully updates memory. If these stale instructions reference sensitive data, their effects may alter the microarchitectural state in a way that leaks secrets, such as cryptographic keys or private user data.
Exploitation typically requires the attacker to run code on the same physical processor core as the victim and have detailed knowledge of processor behavior. Once successful, this attack can lead to unauthorized access to protected data, privilege escalation, or system-wide information leaksóviolating isolation boundaries between processes, users, or virtual machines.","1. CPU Cache Hierarchies (L1/L2/L3)
2. Register Files and Renaming Buffers
3. Translation Lookaside Buffers (TLBs)
4. Branch Prediction Units and Return Stack Buffers (RSBs)
5. Execution Ports and Functional Units
6. Prefetchers and Load Buffers
7. Shared Memory Regions across threads/VMs",Confidentiality,"Read Memory, Unauthorized data exposure, Cryptographic key leakage, Cross-domain information leaks"
CWE-203,Observable Discrepancy,"This vulnerability arises when a system reveals differences in behavior, such as timing, error messages, or control flow, that correlate with internal states. These discrepancies may seem minor, but they can leak sensitive information to unauthorized observers.

Attackers exploit such variations through side-channel attacks, measuring response times, power usage, or external signals to infer secrets like valid usernames, cryptographic keys, or firmware validity. These attacks typically require no code injectionóonly observation and repeated interaction, making them particularly stealthy and effective. Over time, even subtle patterns can be leveraged to bypass security mechanisms or extract confidential data.","1. Authentication System: Timing or message variations can reveal valid usernames or password status, aiding brute-force or enumeration attacks.
2. Cryptographic Modules: Non-constant-time operations may leak key material through timing or power analysis during encryption or signing.
3. Secure Boot / Firmware Validation: Differences in boot timing or status indicators may reveal whether the firmware is trusted or tampered with.
4. Trusted Execution Environments (TEEs): Observing behavioral shifts between secure and non-secure states may leak access permissions or execution context.
5. Hardware Security Modules (HSMs) / TPMs: Timing and power discrepancies during key operations may expose internal state or private key material.","Confidentiality, Access Control","Leakage of sensitive information
Bypass of authentication or cryptographic protections
Side-channel key extraction"
CWE-325,Missing Required Cryptographic Step,"This vulnerability occurs when a cryptographic operation omits necessary steps, such as integrity verification, key validation, or proper authentication, resulting in a false sense of security. Although encryption or decryption may function, the absence of essential safeguards can leave systems open to data manipulation, spoofing, or unauthorized access. Attackers exploit these gaps by modifying encrypted data, injecting malicious inputs, or replaying messages to alter system behavior. For example, if integrity checks are missing, tampered ciphertext may go undetected. If key verification is skipped, attackers may substitute weak or unauthorized keys to compromise protected data or operations.","1. Secure Messaging Protocols: Missing integrity checks can enable undetected message tampering or spoofing.
2. Firmware Update Mechanisms: Failure to verify digital signatures or hashes allows unauthorized or malicious firmware installation.
3. Encrypted Storage Modules: Omitting authentication steps can result in undetected data corruption or manipulation.
4. Authentication Tokens:  Without challenge-response or freshness checks, attackers can replay old tokens to gain access.
5. Cryptographic Accelerators / HSMs:  Skipping required checks (e.g., padding, key size) can lead to misuse or exploitation of secure hardware.","Confidentiality, Integrity, Authorization, Access Control, Accountability, Non-Repudiation","Data tampering without detection
Unauthorized access or spoofing
Compromise of cryptographic protections"
CWE-1240,Use of a Cryptographic Primitive with a Risky Implementation,"This vulnerability occurs when a system uses cryptographic primitives that are outdated, unvetted, insecure, or implemented incorrectly. While the cryptographic functionality may seem to work, such implementations often lack essential security properties and can expose the system to data leakage, spoofing, or privilege escalation.
Attackers may exploit known weaknesses in deprecated algorithms like DES or SHA-1, or target custom cryptographic logic that hasnít been thoroughly reviewed. For instance, using a linear-feedback shift register (LFSR) to generate encryption keys instead of a cryptographically secure random number generator significantly reduces entropy. This makes the key stream predictable, allowing attackers to guess the key and break the encryption, ultimately compromising the systemís security.","1. Cryptographic Accelerators: Use of outdated or insecure primitives (e.g., DES, SHA-1) or flawed logic may expose hardware to side-channel or fault injection attacks.

2. Hardware Security Modules (HSMs) / TPMs: Custom or risky implementations can lead to key leakage or authentication bypass.

3. Secure Elements / Smart Cards: Non-standard cryptographic logic may leak sensitive data through poor design or verification.

4. Key Management Logic: Weak on-chip key generation or exchange mechanisms may compromise confidentiality.

5. Encrypted Hardware Interfaces: Insecure crypto in hardware interfaces (e.g., SPI, I≤C) can enable interception or spoofing.
Encrypted Hardware Interfaces (e.g., SPI, I≤C)
ñ Insecure hardware-level encryption can lead to interception or spoofing attacks.","Confidentiality, Integrity, Authentication","Data exposure due to broken encryption
Unauthorized data modification or injection
Spoofing or bypassing authentication mechanisms"
CWE-1241,Use of Predictable Algorithm in Random Number Generator,"This vulnerability arises when a system uses a pseudo-random number generator (PRNG) with predictable characteristics. PRNGs, by design, have a finite number of internal states and rely on deterministic algorithms, which can result in repeated or guessable output sequences if not seeded properly.

An attacker who observes or reverse-engineers part of the random output may be able to reconstruct the generatorís internal state or seed. Once the state is known, the attacker can predict future outputs of the generator. This enables a variety of attacks such as forging session tokens, predicting cryptographic keys, bypassing authentication mechanisms, or injecting valid-looking malicious data.

Unlike true random number generators, which use physical entropy sources (e.g., thermal noise), weak or misconfigured PRNGs offer no protection against such reconstruction. If used for cryptographic operations, predictable random numbers completely undermine the security guarantees of the system.","1. True random number generator blocks (e.g., thermal or shot noise based): Weak entropy sources may output biased or repeatable bits.
2. On-chip random number generator units: Predictable sequences can compromise boot authentication, key generation, or challenge-response mechanisms.
3. Secure boot engines: Nonces or challenges generated using predictable random number generators can enable replay or spoofing attacks.
4. Cryptographic accelerators: Use of predictable random number generator values in key, IV, or nonce generation weakens encryption.
5. Key derivation hardware: Predictable random number generators reduce effective key space, making brute-force feasible.
6. Hardware security modules (HSMs) / TPMs: Predictable outputs from random number generators may lead to key duplication or impersonation.","Confidentiality, Integrity","Disclosure of sensitive information, compromised cryptographic functions, data forgery"
CWE-1279,Cryptographic Operations are Run Before Supporting Units are Ready,"This vulnerability occurs when cryptographic operations begin before all supporting hardware components-such as random number generators, fuse units, or key storage modules; are fully initialized and ready to provide valid data. Without verifying the readiness of these units, cryptographic engines may process uninitialized or weak inputs, resulting in invalid keys, failed authentications, or insecure outputs. Attackers can exploit such behavior to compromise secure boot sequences, extract sensitive data, or bypass cryptographic protections in hardware security architectures.","1. Hardware Security Module (HSM): May generate weak cryptographic keys if internal random number generator is not properly seeded.
2. Trusted Platform Module (TPM): May retrieve invalid or default keys if fuse-based key storage is accessed before initialization.
3. Secure Boot Verification Unit: May incorrectly validate boot images if cryptographic signature engine is not ready.
4. Cryptographic Acceleration Block: May produce incorrect outputs if key memory or entropy sources are not fully prepared.","Confidentiality, Integrity","Unauthorized data access, authentication failure, encryption compromise"
CWE-1351,Improper Handling of Hardware Behavior in Exceptionally Cold Environments,"This vulnerability arises when hardware components or their associated logic do not account for security-relevant behavior changes at exceptionally cold temperatures. For example, some volatile memories like SRAM or DRAM may retain data longer than expected when cooled, enabling attackers to extract sensitive information after power-down. Additionally, Physical Unclonable Functions (PUFs) or cryptographic modules relying on specific temperature-dependent behaviors may fail or leak information if operated in low-temperature conditions without adequate compensation or safeguards.","1. SRAM-based Physical Unclonable Function (PUF): May produce inconsistent or predictable values under low-temperature conditions.
2. Volatile Memory (e.g., DRAM, SRAM): May retain data unexpectedly when exposed to cold, enabling data remanence attacks.
3. On-chip Temperature Sensors: May fail to detect or compensate for extreme cold, causing incorrect hardware behavior.","Confidentiality, Integrity","Unauthorized data retention, exposure of sensitive information, cryptographic failure"
CWE-1384,Improper Handling of Physical or Environmental Conditions,"This vulnerability occurs when hardware systems fail to handle extreme or abnormal physical or environmental conditions, such as power glitches, electromagnetic interference (EMI), or temperature fluctuations, which can cause unexpected and insecure behavior. Attackers with physical access may exploit these vulnerabilities by injecting faults using methods like voltage glitching, clock glitching, or directed EMI to manipulate hardware operations during sensitive activities.

These techniques can alter instruction execution paths, bypass comparison logic, or corrupt data in registers and memory. For example, a clock glitch could cause a secure boot module to skip signature verification, or a cold temperature-induced retention effect may allow attackers to recover sensitive data from volatile memory after shutdown. Components such as cryptographic engines, secure boot logic, and power/clock management blocks are especially vulnerable if not properly hardened against environmental conditions. The vulnerability typically arises from hardware designs that assume nominal operating environments without validating behavior under abnormal physical stress.","1. Cryptographic Core: May produce incorrect outputs or skip authentication steps under injected faults.
2. Secure Memory Regions: Susceptible to retention attacks or corruption during voltage or temperature manipulation.
3. Clock and Power Management Blocks: May misbehave under clock glitches or EMI, affecting timing-critical security logic.","Confidentiality, Integrity, Availability","Unauthorized access, data corruption, authentication bypass"
CWE-1319,Improper Protection against Electromagnetic Fault Injection (EM-FI),"This vulnerability arises when hardware devices lack adequate protection against electromagnetic fault injection (EM-FI) attacks. In such attacks, adversaries generate transient magnetic fields near the device, inducing currents that can alter internal signals and disrupt normal operations. Exploiting this weakness can lead to bypassing security mechanisms (e.g., secure JTAG or secure boot), leaking sensitive information, modifying program flow, or perturbing secure hardware modules like random number generators. Attackers may use precise EM-FI to skip instructions, corrupt registers, or alter cryptographic operations, especially during security-critical execution phases. Systems that assume ideal operating environments without physical tamper resistance are particularly vulnerable.","1. Secure Boot Modules: EM-FI may disrupt signature verification or force bypass of boot authentication logic.
2. Cryptographic Engines (e.g., AES, RSA cores): Susceptible to fault injection-based key extraction and incorrect encryption behavior.
3. Random Number Generators (RNGs): Fault injection may freeze or skew entropy sources, leading to predictable outputs.
4. Secure Memory Controllers: EM-FI can alter memory protection bits or configuration registers.
5. Control Flow/State Machines: Faults may force illegal transitions in FSMs handling authentication or access control.
6. Fuse/OTP Key Storage Logic: EM-FI may corrupt secure key reads or disable access protections.","Confidentiality, Integrity, Access Control, Availability","Modify memory, read memory, gain privileges, bypass protection mechanisms, execute unauthorized code or commands"
CWE-1247,Improper Protection Against Voltage and Clock Glitches,"This vulnerability arises when a device lacks, or improperly implements, circuitry or sensors designed to detect and mitigate fault injection attacks such as voltage or clock glitches. These glitches can be exploited by attackers to alter the behavior of hardware at critical execution points, particularly during security-sensitive operations like secure boot.
In typical secure boot implementations, the system verifies the digital signature of firmware before execution, forming the first link in a chain of trust rooted in immutable hardware. If the device lacks appropriate glitch detection mechanisms, such as Tunable Replica Circuits (TRCs), Razor flip-flops, or glitch sensors, an attacker can introduce a precisely timed fault (e.g., a voltage dip) during the signature comparison check. This may cause the device to incorrectly evaluate an invalid signature as valid, thereby booting unauthorized firmware.
For example, during secure boot, a voltage glitch injected right when the signature is being verified might cause the conditional check to incorrectly pass, bypassing the firmware authentication. Once secure boot is bypassed, the attacker gains a foothold into the system, potentially allowing unauthorized access to critical assets, execution of malicious code, or full system compromise.
Exploiting this vulnerability typically requires the attacker to have physical proximity or hardware-level access to the device and the ability to control environmental parameters (e.g., power supply or clock signal). However, such attacks have been demonstrated using relatively low-cost fault injection equipment, making this a realistic threat for embedded devices, secure elements, and SoCs lacking robust fault detection circuitry.","1. Secure Boot Logic and Signature Verification FSMs: Logic enforcing cryptographic verification of firmware before execution.
2. Cryptographic Key Registers and OTP Stores: Storage for public keys or device secrets that must be protected from unauthorized use or leakage.
3. Firmware Flash Memory and Bootloaders: Memory regions loaded and validated during boot that could be corrupted or executed improperly.
4. Tunable Replica Circuits (TRCs) and Razor Flip-Flops: Hardware elements that monitor timing violations and voltage anomalies.
5. Voltage/Clock Glitch Detectors and Watchdogs: Sensors that identify fault injection attempts and trigger defensive responses.
6. Critical Control Registers (e.g., MMIO access policies): Configuration elements that enforce security policies during or after boot.","Confidentiality, Integrity, Access Control, Availability","Bypass of secure boot, gain privilege, unauthorized firmware execution, exposure of cryptographic keys, full system compromise"
CWE-1332,Improper Handling of Faults that Lead to Instruction Skips,"This vulnerability arises when a device lacks hardware mechanisms to detect or mitigate the skipping of security-critical CPU instructions caused by fault injection. Attackers can exploit this by manipulating operating conditionsósuch as via voltage glitches or clock anomaliesóto induce instruction skips during sensitive operations.
For instance, injecting a fault during password verification or firmware signature checks could cause the CPU to skip a critical branch instruction, resulting in unauthorized access or acceptance of malicious code.
These attacks are especially dangerous because many security decisions rely on single conditional instructions. Skipping even one can invert logic, compromising secure boot or access control. While such faults may arise under extreme conditions, attackers can reliably induce them using low-cost, precisely timed physical tools.
Exploitation typically requires physical access and equipment to control glitch timing. If successful, attackers may bypass authentication, extract secrets, or manipulate system behavior.","1. Authentication Modules: May be bypassed if instruction skips occur during credential verification.
2. Secure Boot Loaders: Susceptible to unauthorized code execution if signature verification steps are skipped.
3. Cryptographic Operations: Integrity can be compromised if critical instructions are omitted during encryption or decryption processes.                                                                                                                                                                                                                                                                                                                                          4. CPU Instruction Execution Units: Execute conditional or critical instructions related to access control, boot validation, or exception handling.                                                                                                                                                                                                                                                                                                5. Clock and Voltage Monitoring Circuits: Detect timing and voltage anomalies that might indicate a fault injection attempt.                                                                                                                                                                                                                                                                                                                                          6. Fault Detection Logic or Sensors: Monitors instruction timing or flow control anomalies to abort or reset execution upon fault detection.","Confidentiality, Integrity, Authentication","Bypass protection mechanisms, alter execution logic, induce unexpected states"
CWE-1351,Improper Handling of Hardware Behavior in Exceptionally Cold Environments,"This vulnerability arises when hardware devices or their firmware lack appropriate mechanisms to maintain security functions under exceptionally cold conditions. At low temperatures, certain components may exhibit altered behaviors; for instance, volatile memory like DRAM or SRAM might retain data across power cycles instead of resetting. Attackers could exploit this by accessing sensitive information that remains in memory after a reboot in cold environments. Additionally, security primitives such as Physical Unclonable Functions (PUFs) may produce predictable outputs when temperature-sensitive entropy sources are affected by cold, potentially compromising cryptographic operations.","1. Volatile Memory Modules (DRAM, SRAM): May retain data across power cycles in cold conditions, risking exposure of sensitive information.
2. Physical Unclonable Functions (PUFs): Temperature-sensitive entropy sources may yield predictable outputs in cold environments, weakening cryptographic operations.
3. Temperature Sensors and Control Systems: Inadequate monitoring or response to low-temperature conditions can lead to unmitigated security risks."," Integrity, Authentication","Unauthorized access to sensitive data, compromise of cryptographic functions"
CWE-1431,Driving Intermediate Cryptographic State/Results to Hardware Module Outputs,"This vulnerability arises when a hardware cryptographic module exposes sensitive intermediate states or results during cryptographic operations through its output interfaces. Cryptographic algorithms rely on keeping internal computations confidential to maintain security. If intermediate data is inadvertently driven to output pins or accessible registers before the final result is computed, an attacker can monitor these outputs to extract sensitive information, such as encryption keys. This exposure undermines the confidentiality and integrity of the cryptographic process.","1. Cryptographic Accelerator: Dedicated hardware module for performing cryptographic operations (e.g., AES, RSA).
2. Output Interfaces: Pins or registers where the module outputs data, potentially exposing intermediate cryptographic states.
3. Internal Data Buses: Internal pathways within the module that can leak data if not properly isolated.",Confidentiality,Unauthorized access to sensitive information; potential extraction of cryptographic keys
CWE-1278,Missing Protection Against Hardware Reverse Engineering Using Integrated Circuit (IC) Imaging Techniques,"This vulnerability arises when integrated circuits (ICs) lack adequate protection against reverse engineering through imaging techniques such as scanning electron microscopy (SEM) or high-resolution X-ray microscopy. Attackers can exploit this weakness by decapsulating the chip packaging and imaging the IC layers to extract sensitive information embedded in the hardware. This may include secret keys, unique device identifiers, proprietary code, and circuit designs.

A common goal of malicious actors who reverse engineer ICs is to produce and sell counterfeit versions, which replicate the functionality of the original chip without authorization. For example, if an attacker successfully images and interprets a masked ROM layout, they can extract embedded firmware or lookup tables, which can then be cloned or repurposed in fake or cloned devices.","1. Non-Volatile Memory (e.g., Masked ROM): Stores firmware or cryptographic keys that can be extracted through imaging techniques.
2. Proprietary Circuit Designs: Custom logic or unique implementations that, if exposed, could lead to intellectual property theft or cloning.
3. Embedded Secret Keys: Cryptographic keys embedded in hardware for secure operations, vulnerable to extraction via IC imaging.",Confidentiality,"Unauthorized access to sensitive data, cloning or counterfeiting of hardware, intellectual property theft"
CWE-1255,Comparison Logic is Vulnerable to Power Side-Channel Attacks,"This vulnerability arises when a device's comparison logic exhibits variable power consumption patterns during security token evaluations. Attackers can exploit these patterns by monitoring real-time power usage to infer the value of reference tokens. For instance, if the power consumption differs between correct and incorrect token entries, an attacker can iteratively determine the correct token value, potentially leading to unauthorized access or privilege escalation.","1. Authentication Modules: Components responsible for verifying user credentials, which may leak information through power consumption during comparison operations.
2. Cryptographic Processors: Hardware units performing encryption/decryption that could reveal key information if their comparison logic is susceptible to power analysis.
3. Access Control Systems: Devices that grant or deny access based on token validation, potentially vulnerable if their comparison operations are not power-analysis resistant.","Confidentiality, Integrity, Availability, Access Control, Authentication, Authorization,  Accountability, Authorization, Non-Repudiation
","Unauthorized access to sensitive data, execution of unauthorized commands, privilege escalation, bypassing protection mechanisms"
CWE-1300,Improper Protection of Physical Side Channels,"This vulnerability arises when a device lacks sufficient protection mechanisms to prevent physical side channels from exposing sensitive information through observable phenomena such as variations in power consumption, electromagnetic emissions (EME), or acoustic emissions. Attackers can exploit these side channels by monitoring and measuring these physical phenomena to detect patterns and infer sensitive data, even without direct digital access. For instance, by correlating hardware operations with power or electromagnetic measurements, an adversary might recover secret keys or other confidential information.","1. Cryptographic Modules: Implementations of cryptographic algorithms that may leak key information through power consumption or electromagnetic emissions.
2. Authentication Systems: Hardware responsible for verifying user credentials, which could inadvertently reveal authentication tokens via side-channel emissions.
3. Secure Boot Loaders: Components ensuring the integrity of the boot process that might expose execution patterns through physical side channels.",Confidentiality,"Unauthorized access to sensitive data, extraction of cryptographic keys, compromise of secure operations"
CWE-1248,Semiconductor Defects in Hardware Logic with Security-Sensitive Implications,"This vulnerability arises when semiconductor defects occur in hardware logic, leading to faults in internal signals or registers. These defects can cause inputs, outputs, or intermediate signals to be permanently set to 0 or 1, disrupting normal operation. In security-sensitive hardware modules, such faults may compromise security objectives, potentially resulting in unauthorized access or denial of service.","1. Cryptographic Modules: Defects may cause incorrect cryptographic operations, leading to data exposure.
2. Authentication Systems: Faults can result in bypassing authentication mechanisms, granting unauthorized access.
3. Secure Boot Loaders: Defective logic may allow execution of unauthorized code during the boot process.","Availability, Access Control","Denial of Service, Unauthorized Access"
CWE-1190,DMA Device Enabled Too Early in Boot Phase,"This vulnerability arises when a Direct Memory Access (DMA) capable device is enabled before the system's security configurations are fully established during the boot process. DMA allows devices to directly read or write to main memory without operating system intervention. If such devices are activated prematurely, attackers could exploit this to extract data or gain unauthorized privileges by accessing memory regions that should be protected during boot.","1. DMA-Capable Peripherals: Devices like network cards or storage controllers that utilize DMA for efficient data transfer.
2. Memory Management Units (MMUs): Components responsible for memory protection and address translation, which may not be fully configured early in the boot phase.
3. Bootloaders: Software that initializes the system during boot, potentially vulnerable if it enables DMA devices too early.",Access Control,"Bypass protection mechanisms, modify memory"
CWE-1193,Power-On of Untrusted Execution Core Before Enabling Fabric Access Control,"This vulnerability arises when a System-on-Chip (SoC) enables components containing untrusted firmware before establishing memory and fabric access controls during the boot sequence. After an initial reset, it's crucial for trusted firmware to configure SoC fabric access controls and other security features. If untrusted intellectual properties (IPs) or peripheral microcontrollers are activated prior to this configuration, they can initiate transactions on the hardware bus, potentially targeting memory or other critical assets to compromise the SoC boot firmware.","1. System-on-Chip (SoC) Fabric: The interconnect mechanism that links various components within the SoC, vulnerable if access controls are not properly configured.
2. Peripheral Microcontrollers: External controllers that, if untrusted and enabled prematurely, can access and manipulate sensitive system resources.
3. Third-Party Hardware IPs: Integrated components from external vendors that may contain untrusted firmware, posing risks if activated before security measures are in place.",Access Control,"Bypassing of protection mechanisms, unauthorized access to and modification of memory, potential compromise of boot firmware integrity"
CWE-1264,Hardware Logic with Insecure De-Synchronization between Control and Data Channels,"This vulnerability arises when hardware logic responsible for error handling and security checks forwards data before completing necessary security verifications. In high-performance on-chip bus protocols and processor data paths, separate channels for control and data are employed to enhance parallelism and throughput. Bugs in the synchronization between these channels can allow data to be transmitted prior to the completion of security checks. If such data reaches locations observable by an attacker, it can lead to the exposure of sensitive information.

A notable example is the Meltdown vulnerability, where de-synchronization between data access and permission checking logic allowed unauthorized reading of privileged memory.

Similar vulnerabilities can occur in SoC interconnects where the enforcement of access control policies (via a bus firewall) is implemented separately from the data routing logic. For instance, in a system with multiple processors, the firewall may allow or deny access to peripherals based on the privilege level of the requesting core. If the data path and firewall become de-synchronized due to a hardware bug, an unprivileged processor could issue read requests that bypass intended restrictions. In such a case, a processor running untrusted code may be able to access sensitive peripherals like a cryptographic key store, resulting in data leakage.","1. On-Chip Bus Protocols: High-speed communication channels with separate control and data lines vulnerable to synchronization issues.
2. Processor Data Paths: CPU pathways that may forward data before permission checks complete.
3. Error Handling Units: Can leak data if security verification is bypassed due to faulty synchronization.",Confidentiality,"Unauthorized reading of memory, exposure of sensitive application data"
CWE-1274,Improper Access Control for Volatile Memory Containing Boot Code,"This vulnerability arises when a secure boot process copies the initial bootloader from Non-Volatile Memory (NVM) into Volatile Memory (VM) without enforcing sufficient access controls. During early boot, volatile memory may be writable or accessible to peripherals or cores before memory protection features are activated. An attacker can exploit this window to tamper with the boot code in VM, enabling execution of unauthorized instructions, bypassing secure boot, or escalating privileges. Such attacks undermine the foundational trust of the system, as the bootloader governs the integrity of subsequent firmware.","1. Volatile Memory (SRAM, DRAM): Temporarily stores the authenticated bootloader; vulnerable if access protections are not immediately applied.
2. Bootloader Code in Execution Path: Core component of the secure boot chain; its compromise enables arbitrary control of the platform.
3. SoC Internal Buses: Enable data transfer across IPs; if left unguarded, may allow unauthorized agents to overwrite VM contents.
4. DMA-Capable Peripherals: May issue memory writes into VM if not explicitly restricted during early boot.
5. Memory Protection Units (MPUs)/Access Control Logic: Security-critical logic that must be configured early to enforce VM protections.","Access Control, Integrity","Modify memory, execute unauthorized code or commands, gain privileges or assume identity"
CWE-1283,Mutable Attestation or Measurement Reporting Data,"This vulnerability arises when the registers storing attestation or measurement data during the boot process are modifiable by an adversary. In secure or verified boot processes, a System-on-Chip (SoC) measures the code it authenticates by calculating a one-way hash of the code binary and extending it to the previous hash. The final hash serves as the measurement data used in reporting or attestation. If the registers holding this measurement data are not adequately protected, an attacker can alter them, spoofing the measurement and potentially compromising the integrity of the boot process.","1. Measurement Registers: Hardware registers that store cryptographic hashes representing the integrity of boot components.
2. Secure Boot ROM: Performs bootstrapping and hashing operations, relying on the integrity of measurement registers.
3. One-Way Hashing Hardware: Hardware modules that compute cryptographic hashes during the boot process.","Integrity, Confidentiality","Unauthorized modification of measurement data, potential execution of untrusted code, exposure of sensitive information"
CWE-1310,Missing Ability to Patch ROM Code,"This vulnerability arises when a system lacks a mechanism to update or patch the Read-Only Memory (ROM) that stores critical boot-time code. In most secure SoCs, the boot process begins by executing immutable code from ROM, which may include cryptographic verification routines or hardware initialization. If vulnerabilities (e.g., buffer overflows, logic flaws, weak signature checks) exist in this ROM code and cannot be patched post-deployment, attackers can exploit them indefinitely. Adversaries may craft malicious firmware images that exploit flaws in the ROM bootloaders, such as bypassing signature verification or triggering undefined behaviors, to execute unauthorized code or gain privileged access. Since ROM code is immutable, even if a vulnerability is discovered, the attack surface remains unmitigated. Attackers can chain this to escalate privileges, tamper with secure boot, or disable protective mechanisms, particularly in devices deployed in the field without physical access to update the hardware.","1. Boot ROM: A non-modifiable memory region containing the initial code executed during the boot process.
2. System-on-Chip (SoC): Integrated hardware relying on ROM for bootstrapping operations.
3. Root-of-Trust (RoT): Secure boot trust anchor that depends on ROM integrity.","Integrity, Maintainability","Persistent exposure to vulnerabilities, inability to remediate security flaws without hardware replacement"
CWE-1326,Missing Immutable Root of Trust in Hardware,"This vulnerability arises when a System-on-Chip (SoC) lacks an immutable Root of Trust (RoT) in its hardware design. Secure boot processes rely on the RoT to verify the authenticity and integrity of boot code before execution. If the hardware allows modification of critical component, ssuch as boot code, public keys, or system-hardware settings stored in fuses, an adversary can alter these elements to bypass secure boot mechanisms, leading to the execution of untrusted or malicious code.","1. Boot Code Storage: Memory regions (e.g., ROM, flash) containing the initial code executed during the boot process.
2. Public Key Storage: Locations where cryptographic keys used for signature verification are stored.
3. System-Hardware Settings: Configuration data stored in fuses or similar components that dictate security policies, such as enabling secure boot.","Integrity, Authorization",Gain privileges or assume identity; execute unauthorized code or commands; modify memory
CWE-1328,Security Version Number Mutable to Older Versions,"This vulnerability arises when a System-on-Chip (SoC) stores the security version numberóused to enforce rollback protectionóin modifiable memory. During firmware updates, the SoC checks that the incoming firmware has a higher version number and, if valid, stores it for future reference. If this value is stored in writable memory, an attacker with physical or elevated software access can modify it to a lower number to install older, vulnerable firmware (rollback attack), or set it to an abnormally high value to block future updates (denial of service). This enables bypass of secure boot protections and reintroduction of exploitable firmware. For example, in a dual-processor SoC, if one processor is intended to access cryptographic keys while the other runs untrusted code, tampering with the version number and loading downgraded firmware can expose sensitive resources and compromise system trust.","1. Security Version Number Storage: A register or memory location within the SoC that holds the current firmware's security version.
2. Firmware Update Mechanism: The process by which new firmware is authenticated and installed on the device.
3. Boot ROM: Immutable code that initiates the boot process and verifies the integrity and version of the firmware.","Integrity, Authentication, Authorization",Rollback or downgrade to a vulnerable version of the firmware; denial-of-service by preventing legitimate firmware upgrades
CWE-440,Expected Behavior Violation,"This vulnerability occurs when a hardware module or firmware logic behaves differently from what is specified in its documentation or architectural contract. These inconsistencies can result from design flaws, incomplete validation, or poor documentation. Attackers can exploit such mismatches to bypass security mechanisms or trigger unintended behavior. For instance, in the Hack@DAC'21 OpenPiton SoC, the implementation of the sie (supervisor interrupt enable) register incorrectly included a user-accessible signal (utval) in its update logic. Although utval should not influence privileged control registers, its inclusion allowed unprivileged code to indirectly modify how interrupts are managed at the supervisor level. An attacker running untrusted user-mode software could manipulate utval to enable or disable critical interrupts, potentially causing denial of service or escalating privileges. This example highlights how even small deviations from architectural specifications-especially in control registers or privilege boundaries-can introduce serious security risks if they are accessible to lower-privileged software.","1. Privilege-Controlled Registers: System configuration or interrupt control registers expected to be accessible only by privileged software.
2. Interrupt Management Logic: Hardware responsible for masking and routing interrupts that must maintain privilege isolation.
3. Processor Control and Status Registers (CSRs): Registers defining processor state that require strict adherence to privilege boundaries.
4. Memory-Mapped Register Interfaces: Access points for firmware/software where misbehavior can result in unintended exposure or control.","Integrity, Confidentiality, Availability","Quality Degradation, bypass security logic, escalate privileges, perform denial of service, unauthorized access to protected resources"
CWE-1053,Missing Documentation for Design,"This vulnerability arises when a hardware product lacks comprehensive design documentation. Such omissions can hinder understanding, maintenance, and security assessments of the hardware. Inadequate documentation may lead to misinterpretations during integration, overlooked security vulnerabilities, and increased difficulty in implementing necessary updates or patches. For instance, if the design specifications for a cryptographic module are incomplete or missing, it becomes challenging to verify its adherence to security standards, potentially resulting in the deployment of hardware with exploitable weaknesses.","1. System-on-Chip (SoC) Architecture: Documentation covering data flow, control paths, and security boundaries.
2. Hardware Interfaces: Specifications for GPIO, I2C, SPI, and other interfaces to ensure secure integration.
3. Security Features: Descriptions of cryptographic engines, secure boot mechanisms, or access controls for validation.","Integrity, Maintainability",Difficulty in identifying and mitigating vulnerabilities; potential for misconfigurations leading to security breaches
CWE-1059,Insufficient Technical Documentation,"This vulnerability arises when a hardware product lacks comprehensive technical documentation detailing its usage, structure, architectural components, interfaces, design, implementation, configuration, and operation. The absence of such documentation can hinder maintenance efforts, complicate security assessments, and delay vulnerability identification and remediation. For instance, without detailed documentation of a System-on-Chip's (SoC) architecture and interfaces, security analysts may struggle to assess potential attack vectors or verify the correct implementation of security features. This lack of clarity can lead to overlooked vulnerabilities and increased risk of exploitation.","1. System-on-Chip (SoC) Architecture Documentation: Diagrams and descriptions of data flow, control paths, and security boundaries.
2. Interface Specifications: Details for GPIO, I2C, SPI to ensure secure integration.
3. Security Feature Documentation: Information about encryption modules or secure boot processes.
4. Hardware Description Language (HDL) Files: RTL/HDL files for understanding and modification.
5. Bill of Materials (BoM): List of components for supply chain and authenticity checks.","Integrity, Maintainability",Difficulty in identifying and mitigating vulnerabilities; potential for misconfigurations leading to security breaches
CWE-1263,Improper Physical Access Control,"This vulnerability arises when a hardware product lacks sufficient physical protections to prevent unauthorized individuals from accessing sensitive components or data. Physical access can enable attackers to manipulate hardware interfaces, extract confidential information, or alter device functionality. For instance, if a device's debug port is enabled by default without adequate access controls, an attacker with physical access could exploit this port to send and receive unencrypted messages, leading to unauthorized disclosure of information and unintended impacts on device settings and performance.","1. Debug and Test Interfaces: Ports like JTAG or UART that can provide deep access if left unsecured.
2. Memory Modules: Storage containing sensitive data such as encryption keys or firmware.
3. Firmware Storage: Non-volatile memory subject to extraction or tampering.
4. Internal Buses: Component interconnects that may be probed to intercept or alter data.","Confidentiality, Integrity, Access Control",Unauthorized access to sensitive information; potential manipulation or disruption of device functionality
CWE-1277,Firmware Not Updateable,"This vulnerability arises when a hardware product lacks the capability to update or patch its firmware post-deployment. Firmware serves as the foundational software that controls hardware functionality. Without the ability to update it, any discovered vulnerabilities or functional bugs remain unaddressed, leaving the device perpetually susceptible to exploitation. For instance, if a critical security flaw is identified in the firmware of a deployed IoT device and the firmware is not updateable, attackers could exploit this flaw to gain unauthorized access, disrupt operations, or exfiltrate sensitive data. This limitation not only affects individual devices but can also compromise entire networks, especially if the vulnerable devices are interconnected.","1. Embedded Systems: IoT sensors or medical implants with non-updateable firmware pose long-term security risks.
2. Network Routers and Switches: Vulnerable firmware can be exploited to intercept or reroute data.
3. Industrial Control Systems (ICS): Inability to update firmware leaves infrastructure exposed to persistent threats.","Confidentiality, Integrity, Availability, , Access Control, Authentication, Authorization","Gain privileges or assume identity, bypass protection mechanisms, unauthorized access, data breaches, service disruptions, and potential compromise of entire device ecosystems."
CWE-1301,Insufficient or Incomplete Data Removal within Hardware Component,"This vulnerability arises when a hardware component's data removal process fails to completely delete all data and potentially sensitive information. Physical properties of hardware devices, such as magnetic media remanence, residual charges in ROMs/RAMs, or screen burn-in, may retain sensitive data even after a data removal process has been executed and power has been removed. For example, repeatedly writing the same value to a memory location can physically alter the memory cells, allowing data recovery through physical characterization even after erasure.","1. Non-Volatile Memory Modules: EEPROMs or flash memory retaining sensitive data due to incomplete erasure.
2. Magnetic Storage Devices: Hard drives or tapes with data recoverable from remanence.
3. Display Panels: Screens revealing prior content due to burn-in effects.",Confidentiality,Unauthorized access to sensitive information through data remanence
CWE-1329,Reliance on Component That is Not Updateable,"This vulnerability arises when a product incorporates a component that cannot be updated or patched to address vulnerabilities or significant bugs. If such a component is found to contain a security flaw or critical bug, and it cannot be updated, the product owner is left without a means to remediate the issue. This situation can leave the product susceptible to exploitation or operational failures, potentially necessitating complete replacement of the affected product, which may be financially or operationally unfeasible.","1. Read-Only Memory (ROM): Critical for boot processes but immutable once fabricated.
2. Hardcoded Cryptographic Keys: Fixed keys in hardware that cannot be rotated or updated if compromised.
3. Legacy Hardware Components: Older modules that lack firmware update support and remain vulnerable.","Confidentiality, Integrity, Availability","Unauthorized access, data breaches, service disruptions, and potential compromise of the entire device ecosystem"
CWE-1357,Reliance on Insufficiently Trustworthy Component,"This vulnerability arises when a product integrates a component-hardware or software-that lacks sufficient trustworthiness to meet security, reliability, updateability, and maintainability expectations. Incorporating such components can introduce significant risks, including unpatchable vulnerabilities, hidden malicious functionalities, or components that fail to meet specified standards. For instance, utilizing an outdated third-party library with known security flaws can expose the entire system to exploitation.","1. Third-Party Hardware Modules: External parts lacking security verification.
2. Open-Source Software Libraries: Firmware dependencies with unvetted or outdated security posture.
3. Legacy Components: Outdated modules no longer receiving updates or patches.","Confidentiality, Integrity, Availability","Unauthorized access, data breaches, system compromise, and potential introduction of malicious functionalities"
CWE-1429,Missing Security-Relevant Feedback for Unexecuted Operations in Hardware Interface,"This vulnerability arises when a hardware interface silently discards operationsósuch as invalid writes, dropped packets, or hardware errorsówithout providing any feedback or alert to the system. While some systems intentionally suppress feedback to avoid leaking internal details, this must be carefully managed. If security-critical events go unreported, failures or attacks may remain undetected. Attackers can exploit this silence to bypass security monitoring or cause system instability. For example, in a System-on-Chip (SoC), if write operations to reserved memory addresses are blocked but not logged, repeated unauthorized access attempts by an attacker could go unnoticed. In another scenario, uncorrectable errors during data transfers across the SoC fabric (e.g., between the CPU and memory controller) may not be reported to the execution core. Without alerts, the core may proceed to use corrupted data, leading to silent data corruption (SDC). This is especially dangerous in confidential computing systems where the firmware responsible for error handling might be untrusted or misconfigured. To exploit this vulnerability, an attacker usually needs technical knowledge of the system and the ability to trigger invalid or unexpected operationsóthough they may not require high privilege levels. The absence of feedback weakens the systemís ability to detect attacks, troubleshoot issues, or maintain trust in critical operations.
","1. CPU-Core to Interconnect Communication Path: Internal buses where undetected data errors can cause logic corruption.
2. Security/Control Registers: Registers like interrupt masks or debug controls that must alert on failed or invalid access attempts.
3. SoC Fabric/Error Reporting Units: Responsible for surfacing hardware errors; feedback suppression weakens observability.
4. Memory Controllers and DMA Engines: Failure to report invalid access patterns can corrupt memory without detection.
5. Confidential Computing Firmware Interfaces: Interfaces managing trust status or error feedback‚Äîsilence here breaks isolation assumptions.","Confidentiality, Integrity, Availability","Read or modify memory, Read or modify files or directories, denial-of-service, silent data corruption, undetected hardware failures, weakened security observability, failure to detect or respond to invalid operations."
CWE-1276,Hardware Child Block Incorrectly Connected to Parent System,"This vulnerability arises when signal connections between a hardware Intellectual Property (IP) block (child) and its parent system are incorrect, incomplete, or improperly tied to fixed values. These misconfigurations can silently violate security policies, even if the system appears functionally correct. For example, in systems using Arm TrustZone, each security-aware IP expects a privilege bit input to determine whether incoming data is secure or non-secure. If this bit is accidentally hardwired to indicate ìsecureî (e.g., due to a copy-paste or wiring mistake), then all incoming data, even from untrusted sources, will be incorrectly treated as trusted, potentially granting unauthorized access to secure resources. In another case from the Hack@DAC'21 OpenPiton SoC, several interrupt signals were left unconnected between the core and the Control and Status Register (CSR) module. As a result, the CSR module failed to receive and act upon interrupts, meaning critical system states were not updated as intended. This could lead to information leakage across privilege boundaries. Attackers with knowledge of the system architectureóand the ability to run low-privileged or untrusted codeócan exploit these hardware-level integration flaws to manipulate or bypass protections without needing full system access.","1. Privilege Control Signals: Bits that indicate the privilege level or security state of incoming transactions.
2. Reset and Enable Signals: Improperly connected signals may allow unauthorized reset or disablement of IP blocks.
3. Control and Status Registers (CSRs): Depend on child block signals to maintain secure state updates.
4. SoC Interconnect Signals: Include address and ID signals that determine routing and isolation.","Confidentiality, Integrity, Availability","Bypass of privilege checks, information leakage, failure to enforce access controls, loss of secure state consistency"
CWE-1252,CPU Hardware Not Configured to Support Exclusivity of Write and Execute Operations,"This vulnerability arises when a CPU lacks hardware support to enforce exclusive write and execute permissions on memory regions. In such configurations, an attacker can write malicious code into writable memory areas and subsequently execute it, leading to unauthorized code execution. Modern processors typically offer features like the No-Execute (NX) or Execute Disable (XD) bit, allowing the operating system to mark memory pages as non-executable. However, in CPUs without such capabilities or when these features are not properly configured, all writable memory remains executable. This absence of enforcement mechanisms allows attackers to inject and execute arbitrary code, compromising system integrity and security.","1. Memory Management Units (MMUs): Translate addresses and enforce memory permissions.
2. Memory Protection Units (MPUs): Define read/write/execute attributes for memory regions.
3. No-Execute (NX) Bit: Prevents code execution in designated memory areas.
4. Execute Disable (XD) Bit: Similar feature used to block execution from writeable regions.","Confidentiality, Integrity","Unauthorized code execution, potential system takeover, data breaches, and compromise of system integrity"
CWE-1281,Sequence of Processor Instructions Leads to Unexpected Behavior,"This vulnerability arises when a processor fails to correctly handle specific sequences of instructions, causing it to enter critical failure states such as freezing, crashing, or becoming unresponsive. These issues often result from flaws in the instruction set architecture (ISA) or gaps in the processorís logic when dealing with edge cases. Attackers can exploit this by crafting particular combinations of legal and illegal instructions that disrupt normal operation. These attacks typically require only user-level access and an understanding of the processorís behavior.

For example, in the Pentium F00F bug, Intel processors would freeze completely if the lock ""cmpxchg8b"" instruction was executed with an invalid input, because the processor did not handle the error properly. In the Cyrix Coma bug, repeatedly issuing the ""xchg"" instruction prevented interrupts from being processed, trapping the CPU in an infinite loop. Similarly, the Motorola MC6800 had undocumented instructions that caused the processor to read memory continuously without executing any other code, making it unresponsive. More recently, in the Hack@DACí19 CVA6 SoC, missing checks around atomic instruction handling allowed them to be interrupted, which broke atomicity and could lead to deadlocks in systems sharing memory. These vulnerabilities pose serious risksósuch as denial of service, corrupted shared state, or system-level lock-upóespecially in multi-core or virtualized environments.","1. Instruction Decode Logic: Vulnerable to sequence-based faults or misinterpretation of opcodes.
2. Pipeline Control Units: Susceptible to stalls or lock-ups from malformed instruction sequences.
3. Exception Handling Mechanisms: Should catch invalid sequences to prevent processor crashes.
4. Microcode Firmware: Defines behavior of complex instructions; bugs here can cause critical faults.","Integrity, Availability","Processor deadlock, denial of service, corrupted shared state, system-wide freeze or crash"
CWE-1342,Information Exposure through Microarchitectural State after Transient Execution,"This vulnerability arises when a processor fails to properly clear microarchitectural state following events like exceptions, mis-speculations, or microcode assists. In many processor architectures, such events trigger a flush operation intended to clear results that are no longer required, preventing them from affecting the architectural state visible to software. However, if traces of this transient execution remain in microarchitectural buffers, they can alter the microarchitectural state in a way that exposes sensitive information. Attackers can exploit these remnants using side-channel analysis techniques to infer or extract confidential data.","1. Microarchitectural Buffers: Load/store buffers, reorder buffers, and branch prediction units.
2. Speculative Execution Units: Components handling speculative instruction flow.
3. Microcode Assist Mechanisms: Firmware logic handling complex/exceptional instructions.","Confidentiality, Integrity","Read or modify memory, unauthorized access to sensitive information, potential data leakage, and compromise of data integrity through side-channel attacks"
CWE-276,Incorrect Default Permissions,"This vulnerability arises when hardware components or associated firmware are initialized with overly permissive default access controls. Such configurations can inadvertently grant unauthorized entities access to sensitive hardware resources, leading to potential exploitation. For instance, if a hardware module's control registers are set with default permissions that allow unprivileged software to modify critical settings, it could result in unauthorized configuration changes, compromising system integrity. Similarly, default settings that permit unrestricted access to debug interfaces can provide attackers with avenues to extract sensitive information or manipulate device behavior.","1. Control Registers: Can be altered if initialized with permissive access.
2. Debug and Test Interfaces: Open access may lead to system control or data exposure.
3. Peripheral Access Control Lists (ACLs): Insufficient ACLs may expose hardware peripherals.
4. Memory-Mapped I/O Regions: Broad default permissions can cause unintended register interactions.","Confidentiality, Integrity, Availability","Unauthorized hardware manipulation, data leakage, system instability, and potential for privilege escalation"
CWE-441,Unintended Proxy or Intermediary ('Confused Deputy'),"This vulnerability arises when a hardware component acts as an intermediary, such as a proxy, DMA engine, or bridge, processing requests on behalf of another component without preserving or verifying the request's source. This allows untrusted or low-privileged components to exploit the elevated access of the intermediary to perform unauthorized actions. For example, in a System-on-Chip (SoC), a microcontroller running untrusted user-level (ring-3) code may be blocked from directly accessing sensitive registers in a memory-mapped IP core due to implemented access controls. However, the microcontroller can still configure a Direct Memory Access (DMA) controlleróan authorized componentóto fetch data from the protected registers and write it into a memory region that the microcontroller can read. If the DMA controller does not forward the identity of the original requester (the microcontroller), it performs the transaction under its privileges, effectively bypassing the access restrictions. This misuse of the DMA as a privileged intermediary can result in data exfiltration, privilege escalation, or unauthorized modification of secure components. The attacker only requires knowledge of system behavior and the ability to program the intermediary; direct access to the protected resource is unnecessary. This vulnerability is especially dangerous when intermediaries operate at higher privilege levels and do not enforce identity preservation or end-to-end access control.","1. Direct Memory Access (DMA) Controllers: Can be abused to access restricted memory regions indirectly.
2. Memory Management Units (MMUs): Can be bypassed if intermediary identity is not tracked.
3. Peripheral Access Control Modules: Indirect access through intermediaries can break intended restrictions.
4. SoC Interconnects and Buses: Enable data paths where initiator identity may be lost or ignored.","Non-Repudiation, Access Control","Unauthorized access, privilege escalation, data exfiltration, indirect modification of secure components"
CWE-1189,Improper Isolation of Shared Resources on System-on-a-Chip (SoC),"This vulnerability arises when a System-on-a-Chip (SoC) fails to properly isolate shared hardware resources, such as memory, pins, buses, or peripherals, between trusted and untrusted agents. To optimize functionality within limited hardware constraints, SoCs often use techniques like pin multiplexing, where a single pin performs multiple roles, or allow internal resources like SRAM or DMA to be shared among multiple components. Without strict isolation or access controls, untrusted components may gain unintended access to assets reserved for secure or privileged operations.

For example, in a system where the Hardware Root of Trust (HRoT) shares local SRAM with general-purpose cores, the SRAM may serve as a mailbox for communication between trusted and untrusted domains. If the interface controlling access to the shared memory does not properly restrict communication in secure or privileged modes, malicious software on an untrusted core could read or modify sensitive data intended only for the HRoT. Exploiting this vulnerability typically requires knowledge of the memory map and access to an untrusted agent (e.g., core or peripheral) that shares hardware with the trusted domain. This can allow attackers to bypass access control, exfiltrate data, or corrupt system state, violating key security guarantees within the SoC.
","1. Shared Memory Regions (e.g., SRAM): Risk of unauthorized access by untrusted cores.
2. Pin Multiplexing Interfaces: Shared GPIOs or peripheral controls can enable misuse.
3. Internal Buses and Interconnects: May expose sensitive traffic to untrusted agents.
4. Shared DMA Engines or Peripherals: Can be misused to access secure data without direct privilege.","Access Control, Integrity","Bypassing of protection mechanisms, unauthorized access to sensitive data, degradation of system integrity, and potential privilege escalation"
CWE-1192,Improper Identifier for IP Block used in System-On-Chip (SoC),"This vulnerability arises when a System-on-Chip (SoC) lacks unique, immutable identifiers for each of its Intellectual Property (IP) blocks. In an SoC, multiple IP blocks with varying trust levels interact to perform complex functions. Without distinct and unchangeable identifiers, it becomes challenging to enforce security policies, route transactions accurately, and manage access controls effectively. For instance, if an SoC's security architecture relies on identifying the source of a transaction to grant or deny access to sensitive resources, the absence of unique identifiers can allow unauthorized IP blocks to masquerade as trusted ones, leading to potential data breaches or unauthorized operations. This issue can manifest in several ways:?
1. Missing Identifier: The SoC does not implement any mechanism to uniquely identify its IP blocks.?
2. Insufficient Identifier: The identification mechanism exists but lacks robustness, making it susceptible to spoofing or collisions.?
3. Misconfigured Identifier: The identification mechanism is present but improperly implemented or configured, leading to unreliable identification.?
4. Ignored Identifier: Unique identifiers are assigned but not utilized effectively in enforcing security policies.                                                                                                                                                                                                                                                                                                                                       Exploiting this vulnerability typically requires knowledge of the SoC's architecture and the ability to introduce or manipulate IP blocks within the system.","1. Interconnect Fabric: Ensures secure routing of data between IP blocks.
2. Access Control Modules: Enforce security policies based on IP identities.
3. Debug and Test Interfaces: Need proper identification to prevent unauthorized use.
4. Peripheral Controllers: Must verify identity before granting control or access.","Access Control, Integrity","Bypassing of protection mechanisms, unauthorized access to sensitive resources, potential privilege escalation, and compromised system integrity"
CWE-1220,Insufficient Granularity of Access Control,"This vulnerability arises when a hardware system enforces access control policies that are too broad or lack sufficient granularity, allowing unauthorized agents to access security-sensitive assets. In System-on-a-Chip (SoC) designs, multiple components with varying privilege levels interact with shared resources such as memory, registers, or peripherals. If access control logic does not differentiate between types of access (e.g., read vs. write) or between distinct agents with varying trust levels, untrusted components may gain access to critical system resources, potentially leading to data leakage, unauthorized modifications, or loss of control over secure operations.

For example, consider a cryptographic module where AES keys are stored in dedicated registers. If the hardware only uses a single access control policy for both reading and writing these registers, a less-trusted agent (such as an application core or user-level software) could gain write access and overwrite keys, or read keys that should only be accessible by a secure cryptographic engine or trusted firmware. In another case, from the HACK@DACí19 CVA6 SoC, a shared access control entry was used for two different interrupt controllers on the AXI bus. This lack of separation allowed lower-privileged components to access and modify interrupt settings intended only for higher-privileged agents, potentially affecting system behavior or availability. A similar issue can arise when only one bit is used to represent both read and write permissions for a memory region, resulting in write access to memory that was supposed to be read-only for unprivileged agents.

Exploiting this vulnerability typically requires knowledge of the system's memory map and access to a lower-privileged agent capable of interacting with shared interfaces. An attacker may craft software or configure hardware to perform unauthorized reads or writes, bypassing intended protections and compromising confidentiality, integrity, or availability within the SoC.","1. Cryptographic Key Registers: May be overwritten or leaked.
2. Interrupt Controller Configuration Registers (PLIC, CLINT): Unauthorized access may disrupt OS behavior.
3. Memory Protection Regions: Weak encoding may enable write access to secure or read-only memory.
4. Control and Status Registers (CSRs): Untrusted agents may modify secure state.
5. Secure Firmware Memory: May be read or corrupted by lower-privileged cores.
6. Trusted Peripherals (e.g., TPM, HSM): Improper policies may expose these to attackers.","Access Control, Confidentiality, Integrity, Availability","Unauthorized access or modification of secure memory or configuration registers, bypassing of protection mechanisms, privilege escalation, data leakage, and denial of service"
CWE-1222,Insufficient Granularity of Address Regions Protected by Register Locks,"This vulnerability arises when a hardware system employs a single register lock control bit to protect a large address region, leading to conflicts between functional requirements and security policies. In System-on-a-Chip (SoC) designs, certain configuration controls need to be programmed after a device power reset by trusted firmware or software modules (commonly set by BIOS/ bootloader) and then locked to prevent further modification. This is typically implemented using a programmable lock bit that enables or disables writing to a protected set of registers or address regions. However, if the protected region defined by the lock bit is too large, it can result in scenarios where some addresses need to remain writable during operation, conflicting with the security requirement that mandates setting the lock bit during the boot process. For example, consider an SoC where a single lock bit protects a large memory-mapped configuration space. Once this lock bit is set during the boot process to secure critical configuration registers, it also inadvertently locks other registers that need to remain writable during normal operation. This lack of granularity forces developers to choose between leaving the entire region unlocked, exposing critical registers to potential unauthorized modifications, or locking the entire region, hindering necessary functional operations. Such a design flaw can lead to security risks, including unauthorized access or modification of sensitive configuration settings.","1. Configuration Registers: May prevent legitimate updates if locked too broadly.
2. Memory-Mapped I/O Regions: Coarse lock may block dynamic peripheral configurations.
3. Security Control Registers: Risk of being left unprotected or overly restricted.","Access Control, Integrity","Inability to enforce security policies without compromising functional requirements, unauthorized modification of critical configuration settings, and potential system instability"
CWE-1242,Inclusion of Undocumented Features or Chicken Bits,"This vulnerability arises when a hardware device incorporates undocumented features or 'chicken bits'óhidden functionalities not disclosed in official documentation. Manufacturers may include these to disable certain security features, facilitate debugging, or isolate faulty components. While intended for internal use, if these features remain accessible in production devices, they can serve as entry points for unauthorized actors to bypass security mechanisms, modify or read sensitive memory, execute unauthorized code, or escalate privileges.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              For example, a processor might have an undocumented instruction that disables its internal encryption module. An attacker with knowledge of this instruction could exploit it to disable encryption, leading to potential data exposure. Similarly, an undocumented hardware register might allow overriding access controls, granting unauthorized access to protected memory regions.?
Exploiting this vulnerability typically requires detailed knowledge of the hardware's architecture and the existence of these undocumented features. Attackers may obtain this information through reverse engineering, insider knowledge, or leaked documentation.","1. Undocumented Control Registers: Can disable security mechanisms or modify protected behavior.
2. Secret Debug Interfaces: May allow unauthorized access to privileged operations.
3. Hidden Test Modes: Could bypass normal boot and authentication routines.
4. Proprietary Instruction Sets: Enable low-level hardware state manipulation.","Access Control, Confidentiality, Integrity, Availability","Unauthorized access to or modification of sensitive data, execution of malicious code, disabling of security features, and potential system instability or denial of service"
CWE-1260,Improper Handling of Overlap Between Protected Memory Ranges,"This vulnerability arises when a hardware system allows overlapping memory address regions, which can undermine memory protection and lead to privilege escalation or unauthorized data access. In System-on-a-Chip (SoC) designs, Memory Protection Units (MPUs) are used to enforce access control policies over specific memory regions. However, if the MPU does not correctly detect or handle overlapping definitionsóespecially in systems where memory region configurations are programmable by softwareóthen lower-privileged software may craft overlapping mappings to bypass intended security policies.

For instance, consider a system with separate memory regions for privileged and non-privileged software. If non-privileged software is allowed to define or modify memory mappings, it could intentionally configure a new region that overlaps with an existing privileged region. If the MPU treats overlapping regions independently without enforcing proper priority or access policy reconciliation, the non-privileged software may gain read or write access to protected data. In one practical example, an SoC defines AES key storage and UART buffers as separate memory-mapped regions. Due to incorrect region sizing, the UARTís memory region overlaps with that of the AES core, enabling untrusted software with UART access to inadvertently or maliciously access the AES key registers. Similarly, in a simplified MPU configuration with multiple programmable regions, a non-privileged agent may redefine its region to interfere with or mask privileged memoryópotentially even denying access to higher-privileged components.

Exploiting this vulnerability requires knowledge of the SoCís memory layout and the ability to program memory regions (typically available to low-privileged or boot-stage software). The attacker may achieve unauthorized data access, tampering with secure components, or even denial of service by corrupting memory access for privileged code. Overlapping address regions are particularly dangerous in virtualized, multi-agent, or configurable systems where software-controlled memory partitioning is common, and must be rigorously checked for boundary violations.","1. AES Key Registers and Crypto Cores: Risk of exposure via overlapping with untrusted regions.
2. Secure Boot Memory Region: Must remain isolated from remapping.
3. Privileged Configuration Registers: May be tampered with through overlap.
4. System Firmware Memory (HRoT, Trusted FW): Can be read or corrupted.
5. Interrupt and Exception Vector Tables: Targeted for execution hijacking.
6. Memory Protection Unit (MPU) Configuration Registers: Exploitable for defining overlapping mappings.","Access Control, Confidentiality, Integrity","Unauthorized read/write access, privilege escalation, data leakage, tampering with protected components, denial of service through masked or corrupted memory access"
CWE-1262,Improper Access Control for Register Interface,"This vulnerability occurs when a hardware system fails to enforce proper access controls on memory-mapped I/O (MMIO) registers that serve as interfaces to critical hardware functionality. In System-on-Chip (SoC) designs, software commonly interacts with peripherals via MMIO. If access control mechanisms are missing, misconfigured, or insufficiently granular, untrusted or lower-privileged software can tamper with these registers, leading to breaches in confidentiality, integrity, or privilege boundaries.

For instance, a cryptographic accelerator may expose key material or configuration controls through its registers. If these registers are accessible to general-purpose software, an attacker could read secret keys, disable encryption, or change cryptographic modes. Similarly, in the HACK@DACí19 CVA6 SoC, improper privilege checks allowed user-mode software to access the machine exception program counter (MEPC)óa register that should only be accessible in machine modeóenabling potential privilege escalation.

Exploiting this vulnerability typically requires the ability to execute code on the target system and knowledge of the MMIO map. An attacker may then craft software that reads sensitive data, modifies hardware state, or bypasses privilege checks, ultimately compromising system security.","1. Cryptographic Key Registers: Contain sensitive keys; access must be restricted.
2. Privileged Control Registers (e.g., MEPC, MSTATUS): Govern secure state transitions.
3. Peripheral Configuration Registers: DMA, UART, GPIO behavior may leak or manipulate hardware state.
4. Interrupt Configuration Registers: Could be misused to disable or reroute interrupts.
5. Security Configuration Registers: Affect boot, debug, and access control policies.","Access Control, Confidentiality, Integrity",Read Memory; Read Application Data; Modify Memory; Modify Application Data; Gain Privileges or Assume Identity; Bypass Protection Mechanism; Unexpected State; Alter Execution Logic; Unauthorized access to or modification of secure configuration/state;  deactivation of security features; exfiltration of sensitive information
CWE-1267,Policy Uses Obsolete Encoding,"This vulnerability arises when a hardware system uses an outdated or deprecated encoding scheme to implement access control policies, leading to improper enforcement of security boundaries. In System-on-a-Chip (SoC) architectures, bus transactions are often accompanied by security tokensóbits of metadata that inform destination components about the source's trust level and access rights. These tokens are typically derived using a policy encoder. If the encoding logic is inherited from older designs or lacks support for new access control needs, it can misclassify untrusted agents as trusted, allowing them to access sensitive hardware resources such as cryptographic key registers.
For example, consider a system where bus masters are assigned security tokens, and transactions use those tokens to control access to AES key registers. If the system uses an obsolete policy that classifies all ""odd"" tokens as trustedóbased on legacy assumptionsóthen a newly added untrusted bus master with token ""11"" (odd) may incorrectly be granted full access to the AES key registers. This flawed classification allows attackers controlling the untrusted master to exfiltrate or tamper with secret keys. Exploiting this vulnerability requires the ability to initiate or manipulate bus transactions and knowledge of how security tokens are encoded and interpreted. Attackers may then craft transactions that bypass access controls by leveraging weaknesses in the outdated encoding logic, potentially leading to unauthorized access, privilege escalation, or compromise of cryptographic operations.","1. Cryptographic Key Registers (e.g., AES, RSA engines): May be exposed via misclassified bus transactions.
2. Access-Controlled Peripheral Registers: Risk of improper access due to legacy token rules.
3. Interconnect Security Tokens (Trust Labels): Susceptible to spoofing or misclassification.
4. Bus Arbitration and Transaction Control Logic: May grant access to protected resources.
5. Memory-Mapped Secure Zones (Trusted Boot, Firmware): Could be read or tampered with under faulty encoding.","Access Control, Confidentiality, Integrity","Modify Memory; Read Memory;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Modify Files or Directories; Read Files or Directories;                                                                                                                                                                                                                                                                                                                                                                                                                                                       Denial-of-Service: Resource Consumption (Other);                                                                                                                                                                                                                                                                                                                                                                                                                                                        Execute Unauthorized Code or Commands;                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Gain Privileges or Assume Identity;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Unauthorized access to cryptographic secrets or secure firmware regions;                                                                                                                                                                                                                                                                                                                                                                                                     Bypass Protection Mechanism; Reduce Reliability; Data exfiltration, and potential loss of trust in system-wide access control"
CWE-1268,Policy Privileges are not Assigned Consistently Between Control and Data Agents,"This vulnerability arises when a hardware system's access control policies inconsistently assign privileges between control agents (entities that configure access control) and data agents (entities that access or modify data). In System-on-a-Chip (SoC) designs, multiple components interact with shared resources, and access control is often implemented via privilege-encoded registers. If an untrusted agent is mistakenly granted control privilegesósuch as the ability to modify access policiesóit may elevate its own data privileges or those of another agent, leading to unauthorized access or tampering.
For example, consider an SoC with AES key registers protected by three policy registers: one for controlling access to the policy configuration itself, and two others for defining read and write privileges. If an untrusted agent is listed in the control policy but not in the write policy, it may exploit its configuration privilege to insert itself into the write policy register. This enables the untrusted agent to write AES keys or alter secure configuration settings, which were never intended to be accessible at its privilege level. Exploiting this vulnerability typically requires the ability to execute code as an untrusted control agent and knowledge of the privilege encoding scheme. If successful, an attacker may gain write access to cryptographic registers, leak secrets, or compromise the integrity of secure system configurations.","1. Cryptographic Key Registers: Risk of unauthorized writes to sensitive key storage.
2. Access Policy Registers: Can be manipulated to escalate data access privileges.
3. System Configuration Registers: May be altered to change security behavior.
4. Secure Firmware Memory and Boot ROM: Indirectly exposed through privilege mismanagement.
5. Privilege-Encoding Logic in Access Control Units: Needs to be isolated from untrusted agents.","Access Control, Confidentiality, Integrity, Availability","Modify Memory; Read Memory;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Denial-of-Service;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Execute Unauthorized Code or Commands;                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Gain Privileges or Assume Identity;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Bypass Protection Mechanism; Reduce Reliability;                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Privilege escalation, unauthorized tampering of secure registers, data leakage, and compromise of access control logic"
CWE-1280,Access Control Check Implemented After Asset is Accessed,"This vulnerability occurs when a hardware system performs access control checks after allowing access to a protected resource, rather than enforcing the check before the access. In System-on-Chip (SoC) architectures, this sequencing flaw can lead to scenarios where unauthorized components temporarily gain access to sensitive resources, such as secure registers or memory, before the system verifies the initiatorís permissions. This window of exposure may be small, but sufficient for a malicious component to observe, corrupt, or misuse protected data.
For example, consider a design where a hardware module grants access to a secure register based on a grant_access signal that is derived from a user ID. If the access logic updates the register before evaluating whether access should be granted, especially in designs using sequential or blocking assignments, the data may be written or read before the check completes. This race condition creates a security hole, particularly in designs that donít initialize control signals or rely on asynchronous behaviors. An attacker controlling an untrusted bus master or peripheral could exploit this by issuing rapid or concurrent access attempts, hoping to manipulate system timing and access sensitive data before being blocked. Exploiting this vulnerability typically requires knowledge of the access control logic and the ability to initiate transactions from a lower-privileged component. If successful, the attacker may bypass privilege restrictions, leak information, or corrupt critical hardware state.","1. Secure Configuration Registers: Protect boot/debug settings and interrupt routing.
2. Cryptographic Key Registers: Risk of pre-check read/write by untrusted agents.
3. Trusted Firmware Memory (HRoT): Could be accessed if MMIO filter delay exists.
4. Privilege-Sensitive State Machines: Behavior may change from early access.
5. Interconnect Arbitration Modules: Misrouted data due to timing windows.","Access Control, Confidentiality, Integrity","Modify Memory; Read Memory;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Unauthorized data access or modification, leakage of secret information, privilege escalation, and disruption of secure configuration mechanisms;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Bypass Protection Mechanism"
CWE-1294,Insecure Security Identifier Mechanism,"This vulnerability arises when a System-on-Chip (SoC) implements a Security Identifier mechanism to differentiate and identify actions originating from various agents, but the mechanism is not correctly implemented. Security Identifiers are intended to control actions such as 'read', 'write', 'program', 'reset', 'fetch', and 'compute' by assigning unique identifiers to each agent based on their trust level or privileges. Flaws in this process, such as missing security identifiers, improper conversion, or incorrect generation, can lead to unauthorized access or control over sensitive resources. For example, if an SoC's Security Identifier mechanism fails to assign identifiers to certain agents or incorrectly converts bus-transaction signals to security identifiers, untrusted agents may gain unauthorized access to critical assets. This could result in unauthorized reading or writing of sensitive data, execution of privileged operations, or other security breaches. ?Exploiting this vulnerability typically requires an attacker to have control over an agent capable of initiating transactions within the SoC. By leveraging flaws in the Security Identifier mechanism, the attacker can perform actions beyond their intended privileges, compromising the confidentiality, integrity, or availability of the system.?","1. Secure Memory Regions: Require protection based on security identifier validation.
2. Peripheral Devices: Access should be restricted according to security identifiers.
3. Access Control Modules: Enforce identifier-based access filtering.
4. Interconnect Arbitration Logic: Routes based on transaction origin identity.
5. Trusted Boot Logic and Secure Configuration Registers: Must remain isolated from misclassified initiators.","Access Control, Integrity, Confidentiality, Availability",Modify Memory; Read Memory;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Denial-of-Service: Resource Consumption (Other);                                                                                                                                                                                                                                                                                                                                                                                                                                                        Execute Unauthorized Code or Commands;                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Gain Privileges or Assume Identity;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Quality Degradation;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  Data leakage; and control of protected functions.
CWE-1299,Missing Protection Mechanism for Alternate Hardware Interface,"This vulnerability arises when a hardware system implements access controls only on primary interfaces while neglecting alternate or mirrored paths to the same protected assets. In System-on-Chip (SoC) designs, assets such as internal configuration registers or secure data regions are typically protected through interfaces like PCIe. However, if alternate interfacesósuch as UART, USB, SMBUSóor duplicated registers (e.g., shadow or mirror registers) are not equally protected, attackers can exploit these paths to bypass access control and compromise the asset.
For instance, a secure register might be properly protected when accessed through the PCIe interface, but an unprotected copy of that register (a shadow or mirror register) could exist at a different memory address or be reachable through another interface like UART. If this alternate path is not governed by the same access control logic, an attackerósuch as a malicious peripheral or someone with physical accessócould write to the unprotected copy. Because shadow registers are typically synchronized with the main registers, modifying the shadow register can result in unintended changes to the protected register, effectively bypassing security policies. Exploiting this vulnerability requires knowledge of the memory map and access to an alternate, less-protected path. If successful, the attacker can read or modify sensitive information, escalate privileges, or destabilize the system.","1. Secure Configuration Registers: Define privilege, boot, or debug settings.
2. Shadow or Mirror Registers: May reflect into less-protected address spaces.
3. Cryptographic Modules (AES Key Registers): Often mirrored or aliased.
4. DMA Control Registers: May be accessible via alternate buses.
5. Root-of-Trust and Boot Logic: Could be influenced via unprotected paths.
6. Low-Speed Interfaces (UART, SMBUS, USB): May offer unfiltered asset access.","Access Control, Confidentiality, Integrity, Availability","Modify Memory; Read Memory;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Denial-of-Service: Resource Consumption (Other);                                                                                                                                                                                                                                                                                                                                                                                                                                                        Execute Unauthorized Code or Commands;                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Gain Privileges or Assume Identity;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Alter Execution Logic; Quality Degradation;                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Bypassing protction mechanism, data leakage, register overwrite, privilege escalation, system compromise"
CWE-1302,Missing Source Identifier in Entity Transactions on a System-On-Chip (SoC),"This vulnerability arises when a hardware component initiates a transaction within a System-on-Chip (SoC) without including a proper security identifier, which is necessary for enforcing access control. In modern SoCs, transactions, such as read/write requests or commands for compute, reset, or fetch, are typically accompanied by a security identifier that informs the destination module about the identity and privilege level of the originator. This allows the destination to determine whether to permit or deny the requested action.
If a transaction is issued without this identifier, the destination component may be unable to verify the requester's identity. Depending on system behavior, this could lead to two potential consequences: (1) the transaction is dropped entirely, causing denial of service (DoS), or (2) the system defaults to permissive behavior, inadvertently granting access to protected resources. For instance, in an SoC where access to AES encryption key registers is restricted via a policy register indexed by security identifiers, a transaction sent without such an identifier would either be dropped, resulting in failed encryption, or incorrectly allowed, leading to unauthorized key access.
An attacker who can control a component capable of issuing such transactions (e.g., a bus master or peripheral) may intentionally omit or spoof the identifier to bypass security policies. This could result in unauthorized access to cryptographic material, data corruption, privilege escalation, or overall compromise of secure operations. Exploiting this flaw typically requires an understanding of the SoC's interconnect architecture and the security identifier encoding format.","1. Cryptographic Key Registers (e.g., AES, RSA): Vulnerable to unverified access.
2. Secure Firmware Memory or Boot Code Regions: Susceptible to unauthorized fetch/read.
3. Access Policy Registers: At risk of unauthorized modification.
4. Configuration and Debug Registers: Exposure can enable debug access or misconfig.
5. Privilege-Based Memory Partitions: May be breached without source tagging.
6. Security Identifier Routing Logic: Potential bypass point if unverified inputs accepted.","Access Control, Confidentiality, Integrity, Availability","Unauthorized access, privilege escalation, denial of service, policy violation, and data leakage"
CWE-1303,Non-Transparent Sharing of Microarchitectural Resources,"This vulnerability arises when hardware structures within a processor are shared across different execution contexts without adequate transparency or isolation, potentially violating the expected architectural separation between these contexts. Modern processors employ performance-enhancing techniques such as out-of-order execution, speculation, prefetching, data forwarding, and caching. While these techniques are designed to be invisible to programmers, they can inadvertently lead to security risks if shared microarchitectural resources are not properly managed. For instance, contention for shared resources like caches, branch prediction units, or load/store buffers between different execution contexts can create covert channels. Malicious programs executing in one context can exploit these channels to recover sensitive information from another context. Notable examples include side-channel attacks that extract cryptographic keys or bypass address space layout randomization (ASLR) protections. The lack of documentation or transparency regarding the extent of resource sharing exacerbates the difficulty in safeguarding system assets against such disclosures. ","1. Shared Cache Hierarchies (L1/L2/L3): Vulnerable to cache timing attacks.
2. Branch Prediction Units: Can leak control flow via manipulated predictors.
3. Load/Store Buffers: Allow fine-grained analysis of data access patterns.
4. TLBs (Translation Lookaside Buffers): Leak virtual-to-physical access behavior.
5. Execution Units and Ports: Side-channel leakage through port contention.",Confidentiality,"Side-channel leakage of sensitive data, including cryptographic keys or memory access patterns"
CWE-1314,Missing Write Protection for Parametric Data Values,"This vulnerability arises when a device does not write-protect the parametric calibration values used by sensors to convert raw readings into scaled outputs. In System-on-Chip (SoC) designs, sensors are used to monitor critical metrics like temperature, voltage, current, or frequency. These sensors rely on calibration coefficients (e.g., scale and offset) to convert raw hardware data into meaningful units. If these coefficients are not properly protected, untrusted or malicious software can manipulate them to distort the reported sensor readings, potentially bypassing safety checks and damaging hardware.
For example, consider a thermal sensor that converts oscillator frequency into temperature using a formula like:
Temperature = a + b ◊ Sensor_Frequency,
where a and b are software-programmable calibration values. Even if the thermal shutdown threshold is hardware-enforced (e.g., system shuts down at 100∞C), an attacker with access to these calibration registers could set a and b to zero. This forces the temperature reading to always be 0∞C, regardless of actual temperature, preventing the system from detecting overheating and triggering a shutdown. The result could be severe thermal damage or long-term reliability issues.
Exploiting this vulnerability typically requires access to the sensor's calibration registers, which may be available to untrusted software. Attackers who can write to these registers can manipulate the sensor's scaled outputs, leading to integrity violations, physical damage, or suppression of system protections.","1. Sensor Calibration Registers (a, b coefficients): Protect against unauthorized writes.
2. Thermal Protection Units: Dependent on accurate temperature readings.
3. Voltage and Current Sensors: Involved in power safety regulation.
4. Frequency Monitors and PLL Feedback Sensors: Used for clock stability and DVFS.
5. Hardware Safety Monitors and Watchdogs: Trigger protections based on sensor data.
6. SoC Reliability and Lifetime Management Units: Use sensor data to evaluate thermal aging.","Integrity, Availability","Quality Degradation, Falsified readings, hardware damage, safety mechanism failure, Denial-of-Service via overheating or undervoltage"
CWE-1318,Missing Support for Security Features in On-chip Fabrics or Buses,"This vulnerability arises when an on-chip fabric or bus does not supportóor is not properly configured to supportósecurity features such as privilege separation, immutable identity transfer, or access control enforcement. In System-on-Chip (SoC) designs, the interconnect fabric routes transactions between processors, memory, and peripherals. These transactions often include critical security attributes that determine which actions are allowed. If the fabric lacks support for transporting these attributes, or if such support is disabled or misconfigured during RTL generation, the system cannot enforce fine-grained security policies at the destination component.
For example, many SoCs use lightweight buses like AMBA APB that support only a limited number of security bits (e.g., PPROT[2:0]) to represent privilege and secure state. If a CPU supports more identities or privilege levels than the bus can represent, then access control at the slave interface becomes coarse or incomplete. As a result, unprivileged code might write to critical configuration registers such as thermal shutdown thresholds, potentially causing physical damage or a permanent denial-of-service (DoS) attack.
In another scenario, a more configurable fabric such as Open-Core Protocol (OCP) defines optional signals (e.g., MReqInfo for master-to-slave and SRespInfo for slave-to-master security attributes). If these are not instantiated during fabric RTL generation, the security context is effectively lost in transit, and downstream components cannot perform proper access validation. This makes critical assets like power management units vulnerable to manipulation by untrusted or low-privilege agents.
Exploiting this vulnerability typically requires access to an unprotected or under-protected master (e.g., CPU, DMA, or debug port) that can initiate bus transactions. Attackers can craft read or write operations that appear legitimate due to missing or oversimplified security metadata, resulting in unauthorized data access, configuration corruption, and system instability or damage.","1. Privilege-Sensitive Configuration Registers (e.g., thermal thresholds, debug controls)
2. Secure Memory Regions (firmware, key storage)
3. Interrupt Controller Configuration Registers
4. DMA Controller Interfaces: Can be abused for indirect data movement or leakage
5. Power Management Units (PMUs): Control voltages, clocks, and operating modesócritical for system safety
6. Hardware Firewalls and Access Policy Engines
7. Reset Controllers and Clock Gating Units","Access Control, Confidentiality, Integrity, Availability","Privilege bypass, unauthorized register access, memory leakage, denial of service"
CWE-1334,Unauthorized Error Injection Can Degrade Hardware Redundancy,"This vulnerability arises when an unauthorized agent can inject errors into redundant hardware components, thereby compromising system redundancy and potentially leading to degraded operation modes. Redundant hardware blocks are implemented to ensure performance and functional reliability, especially in critical systems. If the design allows unauthorized error injection, these redundant paths may become unavailable, reducing the system's fault tolerance. This degradation can be exploited by subsequent attacks to cause system instability or failure. For example, in systems with dual modular redundancy (DMR) or triple modular redundancy (TMR), unauthorized error injection into one or more redundant modules can skew the majority voting logic, leading to incorrect outputs or system crashes. Similarly, error injection into backup power supply circuits can prevent failover during primary power loss, causing unexpected shutdowns. Exploiting this vulnerability typically requires access to interfaces or mechanisms that allow error injection, which may be exposed due to insufficient access controls. Attackers leveraging these interfaces can induce faults in redundant components, leading to denial of service, reduced reliability, or compromised system integrity.","1. Redundant Processing Units (e.g., DMR/TMR cores)
2. Backup Power Supply Circuits
3. Error Detection and Correction Modules (ECC logic)
4. Redundant Communication Interfaces
5. Safety-Critical Control Systems (e.g., automotive, avionics)","Integrity, Availability","System crash, instability, quality degradation, reduced redundancy, denial of service"
CWE-1311,Improper Translation of Security Attributes by Fabric Bridge,"This vulnerability arises when a fabric bridge, responsible for interfacing between different on-chip communication protocols, incorrectly translates security attributes during protocol conversion. In System-on-Chip (SoC) designs, various Intellectual Property (IP) blocks may utilize different communication protocols, necessitating the use of bridges to facilitate interoperability. These protocols often include security signalsósuch as HPROT in AHB, AxPROT in AXI, and MReqInfo/SRespInfo in OCPóthat convey critical information about the transaction's origin, privilege level, and type.
A weakness occurs if the bridge fails to accurately translate these security attributes, potentially misclassifying the initiator's identity from untrusted to trusted or vice versa. This misclassification can lead to unauthorized access, privilege escalation, or denial of service. For instance, if an untrusted initiator is erroneously granted trusted status due to improper translation, it may access sensitive resources or execute privileged operations, compromising system integrity and confidentiality.","1. Fabric Bridges and Gateways: Components facilitating communication between different protocol domains (e.g., OCP to AHB bridges).
2. Security Attribute Signals (HPROT, AxPROT, MReqInfo): Protocol-specific signals conveying transaction security information (e.g., HPROT, AxPROT, MReqInfo).
3. Access Control Registers: Hardware registers defining access permissions based on security attributes.
4. Sensitive Peripherals (e.g., crypto engines, secure memory): Devices or modules containing critical data or functionality, such as cryptographic engines or secure memory regions.
5. On-Chip Interconnects: Communication pathways linking various IP blocks within the SoC.","Confidentiality, Integrity, Access Control","Unauthorized access, privilege escalation, bypass of protection mechanisms, execution of unauthorized commands."
CWE-1312,Missing Protection for Mirrored Regions in On-Chip Fabric Firewall,"This vulnerability arises when an on-chip fabric firewall is configured to protect a primary memory or memory-mapped I/O (MMIO) region but fails to enforce equivalent protections on its mirrored counterparts. In many System-on-Chip (SoC) architectures, mirrored memory regions are used for fault tolerance or redundancy. These mirrored regions operate in lock-step with the original region, meaning any read or write to a mirrored region can affect the original.
If the firewallís access control policies are only applied to the original region and ignore mirrored regions, an attacker can exploit this by initiating unauthorized operationsósuch as a write transactionóto a mirrored address. Since mirrored regions typically share the same underlying data path, unauthorized writes to a mirrored region will update the protected original memory, effectively bypassing the firewall.
For example, consider a memory controller IP in an SoC that divides physical memory into one original and three mirrored regions. The top two address bits distinguish the regions (e.g., 00 for original, 10 for a mirrored region). If the fabric firewall only blocks writes to the original (00) range, an attacker with access to the bus could write to the 10 mirrored address. Because the regions are synchronized, the original region is still modifiedódespite its protected status.
Exploitation of this vulnerability typically requires that the attacker has the ability to send memory or MMIO transactions on the SoC interconnect (e.g., through a low-privileged CPU, peripheral, or DMA engine). With knowledge of the memory map and mirroring scheme, the attacker can target the mirrored addresses to leak or corrupt protected data, potentially leading to privilege escalation, denial of service, or system instability.
This flaw often results from design oversights during the architecture or implementation phase, where mirrored address ranges are not included in the firewallís rule set or access policy tables.","1. Mirrored and Original Memory Regions: Memory segments mapped to different physical addresses but referencing the same storage resource.
2. Memory Controller Register Blocks: Configuration and control registers that can be mirrored and are sensitive to unauthorized access.
3. Fabric Firewall Access Control Tables: Structures that must enforce consistent policy across original and mirrored ranges.
4. Secure Firmware or Bootloader Code: Stored in protected memory regions that must be uniformly guarded.
5. Memory-Mapped I/O Regions of Critical IPs: Such as power managers, cryptographic engines, or debug controllers.
6. System Configuration and Status Registers (CSR): Frequently mirrored across address space for redundancy or legacy reasons.","Confidentiality, Integrity, Access Control","Unauthorized memory modification, firewall bypass, data corruption, denial of service, privilege escalation"
CWE-1315,Improper Setting of Bus Controlling Capability in Fabric End-point,"This vulnerability arises when a fabric end-point device, intended to function solely as a responder on the system bus, is improperly configured to have bus-controlling capabilities. In System-on-Chip (SoC) architectures, certain devices are designed to either initiate (controller/master) or respond (responder/slave) to bus transactions. To support reusability, some fabric interfaces and end-points provide a configurable register bit that allows IP blocks to access other peripherals connected to the fabric. If this bit is set by default in hardware, or if firmware incorrectly sets it later, a device intended to be a responder on a fabric is now capable of controlling transactions to other devices and might compromise system security.? For example, consider an audio codec chip in a mobile platform that interfaces via PCIe and is intended to be a responder. If the bus-controller-enable register bit is not hardcoded to 0, and there is no platform-firmware flow to verify and enforce this setting, the audio codec could master transactions to the CPU and other platform components. This could potentially allow it to modify assets in other components, subverting system security.? Exploitation of this vulnerability typically requires that the attacker has the ability to modify the configuration of the fabric end-point device, either through firmware manipulation or by exploiting other vulnerabilities that grant access to configuration registers. Once the device gains bus-controlling capabilities, it can initiate unauthorized transactions, leading to data corruption, information leakage, or denial of service.","1. Fabric End-point Devices (e.g., audio codec on PCIe): Devices connected to the system bus intended to function solely as responders.?
2. Bus Controller Enable Register Bit: Configurable bit that determines whether a device can initiate bus transactions.
3. Access Control Mechanisms: Hardware or firmware-based controls that restrict modification of critical configuration registers.
4. Secure Boot Firmware: Firmware responsible for initializing hardware components in a secure state, ensuring proper configuration of devices.
5. System Bus Interconnect: The communication pathway that connects various components within the SoC, facilitating data transfer.",Access Control,"Unauthorized memory access, Modify Memory, Read Memory, Data corruption, Information leakage, Bypass protection mechanism, Denial of service"
CWE-1316,Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges,"This vulnerability arises when the address map within an on-chip fabric permits the definition of overlapping regions between protected and unprotected memory or Memory-Mapped I/O (MMIO) spaces. In System-on-Chip (SoC) architectures, address maps are used to delineate various memory regions, assigning specific access control policies to safeguard sensitive data and critical functionalities. These regions are typically configured using range registers that specify parameters such as base addresses and sizes.
An overlap between protected and unprotected regions can occur due to design limitations (e.g., a restricted number of range registers or constraints in range sizing) or through misconfigurations, either accidental or malicious. Such overlaps can inadvertently expose portions of protected memory within unprotected spaces, allowing unauthorized entities to bypass established access controls. This exposure can lead to unauthorized read or write operations, compromising the confidentiality and integrity of sensitive data.
For example, consider a scenario where a secure bootloader resides in a protected memory region. If an overlapping unprotected region is misconfigured to include part of this secure area, an attacker could exploit this overlap to modify the bootloader code, potentially leading to arbitrary code execution during the system's startup sequence.","1. Address Range Registers: Hardware components that define the base addresses and sizes of memory regions, crucial for access control enforcement.
2. On-Chip Fabric Interconnects: The communication pathways that connect various IP blocks within the SoC, facilitating data transfer and access control enforcement.
3. Protected Memory Regions: Segments of memory designated to store sensitive data or critical code, safeguarded by access control policies.
4. Unprotected Memory Regions: General-purpose memory areas without stringent access controls, intended for non-sensitive operations.
5. Memory-Mapped I/O (MMIO) Regions: Addressable regions used for interfacing with peripheral devices, which may have varying levels of access control.","Confidentiality, Integrity, Access Control, Authorization","Bypassing protection, unauthorized access, privilege escalation, data corruption"
CWE-1317,Improper Access Control in Fabric Bridge,"This vulnerability arises when a fabric bridgeóused to route or translate transactions between heterogeneous bus protocols in a System-on-Chip (SoC)ófails to enforce proper access control mechanisms. In modern SoCs, different Intellectual Property (IP) blocks may operate on different protocols (e.g., AHB, AXI, OCP), requiring fabric bridges to enable interoperability. These bridges must correctly propagate and validate security attributes such as privilege levels, security state, and hardware identities to maintain system-level access control.
If the bridge is connected to a fabric that lacks security features, or if it does not enforce or propagate security metadata (e.g., privilege bits or hardware ID), it may forward transactions from untrusted or lower-privileged agents without verification. This opens the door for unauthorized access to sensitive resources like encryption keys, control registers, or privileged memory. Similarly, if the bridge fails to validate transactions received on its slave sideóespecially when the initiating identity is unclearóit may incorrectly grant access to secure IP blocks.
For example, in the case of CVE-2019-6260, the iLPC2AHB bridge forwarded all transactions from a CPU to peripheral devices without checking the privilege level of the initiator. As a result, even low-privileged or debug-mode software could perform reads and writes to critical system components. Another example is seen in the HACK@DAC'21 OpenPiton SoC. While the AES peripheral correctly gated access using both the AXI interface enable signal and an access control input, the CLINT peripheral failed to do soóallowing any request with a valid bus-level signal to access sensitive interrupt functionality. This highlights how inconsistently enforced access control across different parts of the SoC fabric can lead to vulnerabilities.
Exploitation typically requires an attacker to control a component capable of issuing transactions across the SoC fabric (e.g., a low-privileged core or peripheral). With knowledge of the SoCís architecture and the bridge configuration, the attacker may craft unauthorized transactions to read from or write to protected assets, leading to data leaks, configuration corruption, privilege escalation, or denial of service. Such vulnerabilities often stem from design oversights where bridges are assumed to be passive relays rather than active security enforcement points.","1. Fabric Bridges (e.g., iLPC2AHB, AXI-AHB): Routing points between protocol domains that must enforce security policy.
2. Access Control Registers: Configuration registers enforcing privilege, identity, or security-level filtering.
3. Cryptographic Modules: Peripherals (e.g., AES engines) containing sensitive key material.
4. Interrupt Controllers(e.g., CLINT, PLIC): Secure hardware handling privilege-sensitive interrupt signals.
5. Debug and Test Interfaces: Interfaces exposed through bridges that must be restricted in non-debug modes.
6. Secure Memory Regions (e.g., bootloader): Areas requiring strict isolation from untrusted transactions.
7. Peripheral Configuration Registers: Settings for timers, GPIOs, UART, etc., that can alter system behavior.","Confidentiality, Integrity, Access Control, Availability","Unauthorized access, read or modify memory, bypassed protection, privilege escalation, denial of service"
CWE-1331,Improper Isolation of Shared Resources in Network On Chip (NoC),"This vulnerability arises when the Network-on-Chip (NoC) within a System-on-Chip (SoC) fails to properly isolate internal fabric resources between trusted and untrusted agents. NoCs typically utilize shared architectural componentsósuch as internal buffers, crossbars, switches, output ports, and communication channelsóto facilitate data transfer between IP blocks. When these shared resources lack proper segregation or arbitration based on security domains, it creates opportunities for interference and contention between different trust zones.

Such contention introduces timing channels, enabling attackers to infer sensitive information by observing variations in latency, throughput, or other microarchitectural behaviors. For example, a cryptographic core executing RSA operations may share a communication path with an untrusted agent. If the RSA engineís traffic fluctuates based on the value of secret key bits (e.g., multiplication happens only if a bit is 1), an attacker can send traffic through the same link and measure delays to infer key-dependent activityóultimately enabling side-channel key extraction.
This vulnerability is particularly dangerous in high-assurance or multi-tenant systems, as it compromises confidentiality, availability, and system integrity. It often stems from the assumption that the NoC is a passive transport layer, rather than a potential attack surface requiring active security enforcement.
Attackers typically exploit this vulnerability by controlling a low-privileged master or processor core within the SoC. By generating targeted traffic and analyzing interference patternsóespecially in bandwidth-constrained or shared network linksóthey can deduce secrets from privileged agents operating concurrently.
A real-world scenario includes a 1D mesh NoC topology where packets from both trusted and untrusted agents share a communication link. In such cases, contention on a common link between trusted RSA operations and attacker traffic can be exploited to leak cryptographic keys via timing discrepancies.
To mitigate this, designers must apply domain-aware arbitration, use virtual channels or dedicated buffers for sensitive data, and avoid allowing untrusted agents to share NoC paths with security-critical components.","1. Network-on-Chip (NoC) Fabric Elements: Shared data paths including switches, crossbars, buffers, ports, and routers.
2. Cryptographic Engines (e.g., RSA, AES): Cores performing sensitive operations that must not share traffic paths with untrusted agents.
3. Memory Controllers and DMA Engines: Handling secure memory transactions that require low-latency, non-interfered communication.
4. Secure Firmware Interfaces: Memory-mapped regions or IPC channels used by trusted boot or firmware code.
5. SoC Traffic Management Units: Arbitration logic or packet schedulers that influence prioritization between domains.
6. Privileged Processor Cores Trusted compute agents whose execution timing may vary based on resource contention.","Confidentiality, Availability, Integrity","Side-channel leakage, denial of service, interference with secure operations"
CWE-1256,Improper Restriction of Software Interfaces to Hardware Features,"This vulnerability arises when a device exposes software-controllable hardware functionalitiesósuch as power and clock managementówithout adequate access control. Improperly restricted access to these interfaces can allow attackers to trigger physical attacks like fault injection and side-channel analysis through software alone, without requiring physical access to the system.
Modern System-on-Chip (SoC) designs frequently include features like dynamic voltage and frequency scaling (DVFS) to optimize power consumption, especially in mobile and embedded devices. These mechanisms are often exposed via software-accessible registers. If these registers are left unprotected or are accessible from unprivileged software, an attacker can manipulate them to introduce faults or extract sensitive data.
For example, if clock or voltage scaling interfaces are exposed to untrusted software, an attacker can toggle these settings rapidly to induce software-triggered fault injectionócausing cryptographic operations to behave incorrectly, skip security checks, or reveal sensitive outputs. Similarly, Rowhammer attacks exploit repeated memory accesses to cause bit flips in adjacent DRAM rows, leading to unauthorized data manipulation or privilege escalation.
In parallel, software-exposed power monitoring interfaces (e.g., Intel RAPL) can be abused to carry out power side-channel attacks, where attackers infer sensitive information (e.g., cryptographic keys) by analyzing power consumption patternsóeven in the absence of physical probing.
Exploiting this vulnerability generally requires the attacker to have software execution privileges, even at an unprivileged level, enabling them to access or abuse system interfaces meant for low-level control. If successful, these attacks can compromise confidentiality, integrity, and availabilityóundermining core security guarantees of the platform.","1. Power Management Interfaces (e.g., DVFS Controllers): Used for dynamic voltage and frequency adjustments that may affect execution reliability.
2. Clock Scaling Registers: Exposed registers that control the SoC or peripheral clock domain speeds.
3. DRAM Memory Banks: Vulnerable to Rowhammer-style disturbance faults caused by repeated access.
4. Cryptographic Engines (e.g., AES, RSA): Can be disrupted or leaked through fault injection and power-based side-channel analysis.
5. Power Monitoring Modules (e.g., Intel RAPL, ARM EnergyMon): Can be disrupted or leaked through fault injection and power-based side-channel analysis.
6. Security Control Registers Software-accessible configuration fields governing secure mode transitions, access policies, or privilege settings.",Integrity,"Unauthorized modification of execution state, privilege escalation, leakage of cryptographic secrets, system instability, violation of trust boundaries"
CWE-1271,Uninitialized Value on Reset for Registers Holding Security Settings,"This vulnerability arises when security-critical registersósuch as those controlling debug interfaces, privilege levels, or access controlóare not initialized to a known safe state during system reset. Many hardware flip-flops power up in an undefined state unless explicitly reset, creating a temporary insecure window at boot.
For example, if a debug lock register is not reset to a locked state, it may power up unlocked. An attacker with access to system reset could repeatedly reboot the device until the register powers up in an open state, gaining unauthorized access before the correct value is applied by software or later logic.
This issue is particularly dangerous in systems relying on early hardware-enforced protections (e.g., secure boot or trusted execution). Attackers exploiting this condition may gain temporary access to sensitive configurations, elevate privileges, or bypass access restrictions.
To mitigate this vulnerability, reset logic must explicitly initialize all security-relevant registers to a known, secure value (e.g., lock?=?1 or access?=?disabled). This should apply even to simple flip-flops and control bitsóespecially those tied to sensitive interfaces or system configuration.","1. Debug Interface Lock Registers: Control access to on-chip debugging; must be locked immediately on reset to avoid post-boot access.
2. Privilege Configuration Registers: Select the privilege level for boot or runtime software execution.
3. Access Control Registers (e.g., memory or peripheral protection): Define which agents can access secure regions.
4. Secure Boot Control Registers Determine the boot flow and whether firmware integrity is enforced.
5. Interrupt and Exception Controller Configurations: May allow hijacking control flow if default states are permissive.
6. System Mode Selectors (e.g., test mode, manufacturing fuse controls): Improper initialization may enable backdoors or insecure fallback modes.","Access Control, Authentication, Authorization","Unauthorized access through debug ports, temporary or permanent privilege escalation, bypass of secure boot or trusted execution, compromise of initial boot state"
CWE-1304,Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation,"This vulnerability arises when a hardware component performs a power save/restore operation without ensuring the integrity of its configuration state. During power-down, the component saves its current configuration to persistent storage (e.g., flash or always-on memory). If this stored configuration is not protected against tampering, an attacker with access to the storage medium can modify it. Upon power-up, the component may load the altered configuration, leading to unauthorized behavior such as privilege escalation, disabled protections, or hardware malfunction. ?For instance, in the case of CVE-2024-23485, certain controllers failed to preserve the integrity of their configuration state during power cycles. This allowed secured door locks connected via communication hubs to momentarily allow free access, compromising physical security.","1. Power Management Units (PMUs): Manage power states of the system; compromised configurations can lead to unauthorized power state transitions.
2. System-on-Chip (SoC) Configuration Registers: Hold critical settings; tampering can alter system behavior.
3. Flash Memory Controllers: Store configuration data; lack of integrity checks can allow malicious modifications.
4. Security Modules: Enforce security policies; altered configurations can disable protections.
5. Peripheral Controllers: Manage external interfaces; compromised settings can expose the system to external threats.","Confidentiality, Integrity","Privilege escalation, bypassing protection mechanisms, alteration of execution logic, system instability, reduced system reliability"
CWE-1320,Improper Protection for Outbound Error Messages and Alert Signals,"This vulnerability arises when alert signalsósuch as those generated by hardware sensors monitoring thermal, power, or other critical conditionsóare not adequately protected against unauthorized access or manipulation. Untrusted agents can disable these alerts or generate spurious ones, leading to degraded performance or denial-of-service (DoS). For example, if a thermal sensor's alert signal is routed through a General-Purpose Input/Output (GPIO) pin that is accessible to untrusted software, an attacker could reconfigure the pin to suppress legitimate alerts or trigger false ones. This can prevent necessary remedial actions like system shutdown or throttling, potentially causing hardware damage or system instability. ","1. Thermal Sensors and Alert Signals: Monitor device temperature and generate alerts when thresholds are exceeded.
2. Power Management Units (PMUs): Manage power states and generate alerts for overcurrent or undervoltage conditions.?
3. GPIO Controllers: Interface with alert signals: improper configuration can expose alerts to untrusted agents.
4. System-on-Chip (SoC) Configuration Registers: Hold settings for alert thresholds and routing; must be protected against unauthorized modifications.
5. Firmware (e.g., BIOS): Sets initial configurations for alert mechanisms; must ensure settings are secure and immutable by untrusted software.",Availability,"Denial-of-Service (DoS): Instability, crash, exit, or restart, reduced system reliability, unexpected system states"
CWE-1338,Improper Protections Against Hardware Overheating,"This vulnerability arises when a hardware device lacks adequate protection mechanismsósuch as thermal sensors, effective cooling solutions, or thermal insulationóto prevent overheating. Malicious software can exploit this by operating the device in modes that generate excessive heat, potentially leading to thermal runaway, permanent hardware damage, or safety hazards. For instance, software could execute high-power instructions continuously, causing the device to overheat. Without proper thermal management, this can result in denial-of-service (DoS) attacks.","1. Thermal Sensors: Monitor device temperature to trigger protective actions when thresholds are exceeded.
2. Cooling Systems (e.g., Fans, Heat Sinks): Dissipate heat to maintain safe operating temperatures.?
3. Power Management Units (PMUs): Control power consumption to prevent excessive heat generation.
4. System-on-Chip (SoC) Thermal Management Units: Integrate thermal monitoring and response mechanisms.?
5. Firmware (e.g., BIOS): Configures thermal thresholds and manages responses to overheating",Availability,"Denial-of-Service (DoS),  Safety Hazards"
CWE-1191,On-Chip Debug and Test Interface With Improper Access Control,"This vulnerability arises when a chipís debug and test interfacesósuch as JTAGólack proper access control mechanisms. Without robust authentication or authorization, attackers can exploit these interfaces to bypass on-chip protections, access internal registers, or execute arbitrary code. Simply hiding debug pins (e.g., within motherboard layers) is not a sufficient defense, as determined attackers can still locate and access them using specialized tools. This is particularly concerning because debug interfaces like JTAG provide serial access to internal device registersópotentially exposing nearly all system data.
For example, consider a Wi-Fi router that enforces login credentials to restrict command execution. If the JTAG interface is not properly secured, an attacker could identify it using tools like JTAGulator. By issuing a halt command before the OS boots, the attacker can pause execution, inspect or modify memory, and even extract firmwareóultimately gaining full control of the device.
In summary, poorly secured debug interfaces pose significant risk. Attackers with physical access and modest technical skill can leverage them to extract sensitive data, bypass security controls, or establish persistent control over the system.","1. Internal Registers and Memory: Hold configuration data, firmware state, and user/application data that can be exposed via debug access
2. Firmware Storage: Contains executable code and secrets; vulnerable to extraction or manipulation.
3. Secure Boot Configurations: May be overridden or disabled if the debug interface is exploited before boot.
4. Authentication Mechanisms: Can be bypassed if instruction flow or memory is altered through debug commands.
5. Cryptographic Keys and Certificates: May reside in accessible memory regions or registers.
6. Security Fuses and Lock Bits: Intended to disable debug access but may be left unprogrammed or incorrectly configured.","Confidentiality, Authorization, Integrity, Access Control","Unauthorized access to sensitive data, read application data or memory, modify memory, execution of unauthorized code, firmware extraction or modification, privilege escalation, bypass of authentication and secure boot"
CWE-1243,Sensitive Non-Volatile Information Not Protected During Debug,"This vulnerability arises when security-sensitive values stored in non-volatile memory (e.g., fuses)ósuch as root keys, manufacturing secrets, or OEM dataóare not adequately protected during debug operations. Upon power-on, these values are sensed from fuses and cached in temporary hardware registers or local memories. While access to these locations is typically restricted during normal operation, they often remain accessible in debug mode, creating a critical attack surface.
For instance, if debug interfaces (e.g., JTAG) permit access to microarchitectural registers holding fuse-derived values, an attacker could extract secrets during a debug session. One concrete example involves an AES cryptographic engine that loads keys from fuses into temporary registers during boot. If access to some of these registers remains unblocked in debug mode, an attacker could retrieve unprotected keys, compromising system confidentiality.
Exploiting this vulnerability typically requires debug-level access and physical proximity or prior system compromise. However, since debug interfaces are often left enabled post-deployment for maintenance, attackers with modest hardware skills and tools may extract firmware keys, device identifiers, or other sensitive data.","1. Root Cryptographic Keys: Loaded from fuses or OTP and stored temporarily in registers; used for decryption, attestation, or firmware verification.
2. Device Identity and OEM Secrets: Unique device identifiers and manufacturing data stored in non-volatile memory.
3. Temporary Hardware Registers or Shadow Buffers: Cache fuse-derived values post-boot; often exposed via debug unless locked.
4. JTAG/Debug Interfaces: Access paths through which temporary register content may be observed or dumped.
5. Key Registers in Crypto Modules (e.g., AES Engine): Hold working keys sourced from fuses; vulnerable if not masked during debug.","Confidentiality, Access Control","Unauthorized access to root keys or OEM secrets, bypass of secure boot or firmware authentication, device cloning or impersonation, loss of data confidentiality"
CWE-1244,Internal Asset Exposed to Unsafe Debug Access Level or State,"This vulnerability occurs when a deviceís debug or test interfaceósuch as JTAGósupports multiple access levels but assigns an incorrect debug access level to internal assets. This misconfiguration allows untrusted debug agents to access sensitive resources, particularly if protections based on system state or boot stage are improperly enforced.
Many SoCs implement debug authorization through multiple levels (e.g., early boot debug, limited post-boot access) with access governed by privilege level, passwords, or system state. If the debug mechanism does not ensure that sensitive assets (e.g., registers, memory regions, control logic) are bound to the appropriate debug level during every system state transition, attackers may exploit this gap to extract secrets or tamper with secure operations.
For example, if a JTAG shield bit is unset at reset and only configured later by user software, attackers with debug access before ROM execution can modify the boot process and extract cryptographic keys. In another case, a vulnerable RISC-V debug interface incorrectly updates processor privilege level if either the debug privilege check or the password check passesóallowing attackers to bypass password verification entirely and gain unauthorized debug access.
Exploitation typically requires physical access or pre-existing system control to interact with the debug interface. However, once successful, attackers can halt execution, read or modify memory, alter secure boot logic, or access otherwise protected dataóposing a severe risk to device confidentiality and integrity.","1. Boot ROM and Secure Boot Logic: Vulnerable to tampering or bypass before protections activate.
2. Cryptographic Keys and Certificates: May be stored in registers or memory regions with incorrect debug-level protections.
3. Firmware and Configuration Memory: Can be altered or extracted via improperly secured debug sessions.
4. Privilege and Access Control Registers: May be elevated or overwritten by unauthorized debug-level access.
5. Control and Status Registers (CSR): Critical for controlling system behavior; often exposed in early debug modes.
6. JTAG/Debug Configuration Bits (e.g., Shield Bits, Lock Bits): If unset or delayed in initialization, attackers can exploit them during early boot stages.","Confidentiality, Integrity, Authorization, Access Control","Unauthorized access to secrets, firmware tampering, privilege escalation, bypass of secure boot or debug protections"
CWE-1258,Exposure of Sensitive System Information Due to Uncleared Debug Information,"This vulnerability arises when sensitive dataósuch as cryptographic keys or intermediate valuesóare not fully cleared from internal hardware registers upon entering debug mode. If left uncleared, these values may be exposed to attackers through debug interfaces, leading to system compromise.
For example, cryptographic accelerators in System-on-Chip (SoC) designs often store encryption keys in memory-mapped registers. While normally protected from software access, interfaces like JTAG may still allow reading these registers. If debug mode is entered without zeroizing them, attackers can retrieve secrets directly via debug access.
This threat is especially severe in systems relying on hardware isolationósuch as secure boot or trusted execution environmentsówhere even a single uncleared register can break the security model. A notable example involves AES wrapper modules where only some key registers (e.g., core_key0) are cleared in debug mode. If others (e.g., core_key1) remain intact, attackers can exploit the gap to extract cryptographic material.
Exploitation generally requires access to debug functionalityóeither physically or through misconfigured interfaces. However, as debug logic is increasingly left active in production and inexpensive probing tools become widespread, these attacks are growing more feasible.","1. Cryptographic Keys: Stored in memory-mapped or internal registers; highly sensitive.
2. Intermediate Cryptographic Values: Temporary results (e.g., S-box outputs, round keys) that may leak key material.
3. Debug-Accessible Registers: Registers that can be read via JTAG or similar interfaces if not masked or cleared.
4. Secure Boot Keys / Hash Roots: Often stored in internal storage and vulnerable if not wiped on debug entry.
5. Trusted Execution Environment (TEE) Buffers: Secure memory regions that may contain decrypted or pre-processed data.
6. On-Chip Scratchpads or Shadow Registers: Temporary buffers used by crypto engines and initialization code.","Confidentiality, Access Control","Unauthorized access to cryptographic keys or secret materials, breach of secure boot or TEE isolation guarantees, exposure of firmware verification data or internal authentication mechanisms"
CWE-1272,Sensitive Information Uncleared Before Debug/Power State Transition,"This vulnerability arises when a device transitions between power, debug, or privilege states without properly clearing security-sensitive data that should no longer be accessible. Such data may include cryptographic keys, authentication tokens, or proprietary information cached in registers or memory. If not scrubbed before or during state changes, this leftover data may be exposed to unauthorized entities operating in the new state.
For example, consider a device that operates in a privileged mode (State A) where it accesses secret keys from secure fuses. After transitioning to a less privileged or production mode (State B), direct access to the fuses is blockedóbut if the keys were previously stored in accessible memory and not cleared during the transition, an attacker in State B could retrieve them by reading residual memory contents.
This vulnerability is especially concerning in systems that frequently switch operational statesósuch as embedded or IoT devices with aggressive power management. In such cases, attackers with runtime or debug access may exploit improper state sanitization to leak secrets, bypass privilege boundaries, or compromise secure operations.
To mitigate this risk, sensitive information must be explicitly scrubbed from volatile storage (e.g., SRAM, internal registers) before completing any transition that reduces the system's privilege or trust level.
","1. Cryptographic Keys (e.g., AES, RSA): May be left in volatile memory after secure processing.
2. Session/Authentication Tokens: Temporary credentials stored in RAM or registers for inter-process or device communication.
3. Secure Fuse Values: Loaded into temporary registers from non-volatile fuses during boot, vulnerable if not cleared.
4. Register Banks and Shadow Registers: Used by bootloaders or crypto modules, often unprotected after mode switch.
5. Low Power Memory Regions (e.g., retention SRAM): May retain sensitive data during suspend/resume cycles.
6. Firmware Buffers Containing Secrets: Used by boot stages or crypto APIs that cache data before state transitions.
7. Debug-Visible Memory: RAM or MMIO regions that become visible through JTAG/UART during lower-privileged or debug states.","Confidentiality, Integrity, Availability, Access Control, Accountability, Authentication, Authorization, Non-Repudiation","Leakage of secret data across privilege or power boundaries, bypass of security policies, exposure of cryptographic keys, compromise of secure boot or TEE"
CWE-1291,Public Key Re-Use for Signing both Debug and Production Code,"This vulnerability arises when the same public key is used to verify both debug and production firmware images. In secure boot processes, public-key cryptography ensures firmware authenticity. Reusing the same key for both environments allows a leaked or malicious debug firmware to be installed on production devices, bypassing security checks and enabling deep system access.
Debug firmware often includes diagnostic features like access to test modes, hardware registers, and verbose logsóintended for development but highly sensitive in production. If signed with the same key trusted by production hardware, debug firmware can grant attackers privileged access, undermining isolation and exposing cryptographic assets.
For example, if only one 3072-bit RSA key can be stored in fuse memory, developers may reuse it for both debug and production. If debug firmware leaksócommon in developmentóthe shared key enables it to run on field devices, compromising system integrity.
Exploiting this vulnerability is straightforward once the debug firmware is leaked. Attackers with basic tools can reflash devices, extract secrets, disable protections, or implant persistent backdoors.
To mitigate this risk, separate keys must be used for debug and production firmware, ensuring that debug images cannot be verified or executed on production hardware.","1. Secure Boot Public Key (eFuse or ROM): Used for firmware authentication; must not be shared across environments.
2. Production Firmware Image: The secure and validated image that should run in the field.
3. Debug Firmware Image: Contains diagnostic hooks and privileged interfaces; must be restricted from field use.
4. Root of Trust Module: Executes firmware validation; if improperly keyed, it may load unauthorized images.
5. Hardware Configuration Registers: Often exposed by debug builds, can be tampered with if debug firmware is accepted.
6. On-Chip Cryptographic Keys and Secrets: May be exposed or extracted when debug firmware is loaded on production.
7. Persistent Storage (e.g., Flash, eMMC): Vulnerable to being overwritten with malicious debug firmware.
8. Secure World Memory Regions (in TEE): Debug builds may allow access to trusted execution zone contents.","Confidentiality, Integrity, Availability, Access Control, Accountability, Authentication, Authorization, Non-Repudiation","Read or modify memory, bypass of secure boot or firmware integrity checks, unauthorized execution of debug or malicious firmware, extraction of cryptographic keys and secure configuration data, privilege escalation and persistent system compromise"
CWE-1295,Debug Messages Revealing Unnecessary Information,"This vulnerability arises when debug messages unintentionally reveal sensitive system information such as memory contents, authentication tokens, or internal configurations. While useful during development, such messagesóif exposed in productionócan assist attackers in mapping system internals or exploiting vulnerabilities.
For instance, a debug log may display the Test Access Port (TAP) hierarchy during a scan chain request, or reference a password file path after a failed login attempt. These details, though seemingly minor, can aid in reverse engineering, privilege escalation, or bypassing security controls.
This risk is elevated in systems where debug interfaces like JTAG, UART, or TAP remain accessible, or where verbose logs are not disabled during deployment. Attackers with physical or limited software access can leverage this unintended exposure to compromise system security.","1. Test Access Port (TAP) Hierarchies: May be exposed via logs during scan chain operations.
2. Memory Content Snapshots: Debug logs that print register or memory block contents may reveal sensitive runtime data.
3. Authentication Tokens or Password Paths: Exposed in failure logs or debug outputs after login or config errors.
4. SoC Boot Configuration Registers: Often logged for diagnostics; can reveal security state or boot modes.
5. Debug-Accessible Peripherals (e.g., UART, JTAG): Can be leveraged to extract verbose logs containing system secrets.
6. Security Policy Configuration: Exposed when debug logs echo policy register contents during boot or failure.
7. Cryptographic Operation Traces: May include step-by-step execution info useful in key recovery or side-channel setup.","Confidentiality, Integrity,, Availability, Access Control, Accountability, Authentication, Authorization, Non-Repudiation","Unauthorized access to internal or sensitive configuration data, bypass of privilege levels or secure modes, reverse engineering of firmware behavior or chip architecture, increased attack surface through system reconnaissance"
CWE-1296,Incorrect Chaining or Granularity of Debug Components,"This vulnerability arises when debug components within a system are improperly interconnected or lack appropriate granularity, leading to unintended access permissions. In hardware designs, especially System-on-Chip (SoC) architectures, multiple Test Access Ports (TAPs) and debug interfaces are implemented for testing and troubleshooting purposes. If these components are incorrectly chainedósuch as forming a flat daisy chain instead of a hierarchical structureóor if access controls are not properly enforced at each level, an attacker could gain unauthorized access to internal debug functionalities.? For example, a user might have legitimate access to a top-level TAP (e.g., TAP_A) but should not have access to subordinate TAPs (e.g., TAP_B, TAP_C). However, due to improper chaining, accessing TAP_A inadvertently provides access to all subordinate TAPs, allowing an attacker to execute commands or extract sensitive information from internal components. Such misconfigurations can occur due to logic errors during design or synthesis phases, leading to compromised system security, including unauthorized code execution, modification of memory, or bypassing protection mechanisms.?","1. Test Access Ports (TAPs):  Interfaces used for boundary scan and debugging; improper chaining can expose internal components.
2. Scan Chains:  Sequences of scan cells for testing; misconfiguration can lead to unintended access.
3. Debug Interfaces (e.g., JTAG, SWD): Standard interfaces for debugging; lack of proper access control can be exploited.
4. Internal Registers and Memory: May contain sensitive data; exposed through misconfigured debug components.?
5. Trace Hubs and Monitoring Components: Used for observing internal operations; improper access can leak sensitive information.","Confidentiality, Integrity, Access Control, Authentication, Authorization, Availability, Accountability","Gain of unauthorized privileges or identities, bypassing of protection mechanisms, execution of unauthorized code or commands, modification of memory, files, or directories"
CWE-1313,Hardware Allows Activation of Test or Debug Logic at Runtime,"This vulnerability arises when hardware permits activation of test or debug logic during normal runtime operations. Such activation can alter the intended behavior of the system and allow for alteration and leakage of sensitive data by an adversary. For example, an accessible test/debug mode may allow read/write access to any system data. Using error injection (a common test/debug feature) during a transmit/receive operation on a bus, data may be modified to produce an unintended message. Similarly, confidentiality could be compromised by such features allowing access to secrets.","1. Test/Debug Interfaces (e.g., JTAG, UART): Interfaces that, if improperly secured, can be activated during runtime, leading to unauthorized access.
2. Control and Status Registers (CSRs): Registers that may enable debug modes; if not properly protected, they can be manipulated during normal operation.
3. Memory-Mapped I/O Regions: If accessible during runtime, can be exploited to activate or control debug features.
4. Error Injection Mechanisms: Test features that, if enabled during runtime, can disrupt operations or modify behavior.
5. Secure Boot Configuration Registers: May be vulnerable if accessible or modifiable during runtime.","Confidentiality, Integrity, Availability","Unauthorized modification or reading of memory, execution of unauthorized code or commands, bypass of protection mechanisms, alteration of execution logic, denial of service (DoS)"
CWE-1323,Improper Management of Sensitive Trace Data,"This vulnerability arises when trace data collected from various sources on a System-on-Chip (SoC) is stored in unprotected locations or transmitted to untrusted agents. To facilitate verification of complex SoC designs, integrators add specific IP blocks that trace the SoC's internal signals in real-time. This infrastructure enables observability of the SoC's internal behavior, validation of its functional design, and detection of hardware and software bugs. Such tracing IP blocks collect traces from several sources on the SoC, including the CPU, crypto coprocessors, and on-chip fabrics. Traces collected from these sources are then aggregated inside the trace IP block and forwarded to trace sinks, such as debug-trace ports that facilitate debugging by external hardware and software debuggers. Since these traces are collected from several security-sensitive sources, they must be protected against untrusted debuggers. If they are stored in unprotected memory, an untrusted software debugger can access these traces and extract secret information. Additionally, if security-sensitive traces are not tagged as secure, an untrusted hardware debugger might access them to extract confidential information.","1. Trace Buffers: Temporary storage for trace data; if unprotected, can be accessed by unauthorized entities.
2. Debug Interfaces (e.g., JTAG, UART): Interfaces that, if improperly secured, can be exploited to access sensitive trace data.
3. Trace Aggregators: Components that collect and forward trace data; lack of proper access controls can lead to data leakage.
4. Secure Memory Regions: Areas intended to store sensitive data; if trace data is stored here without proper protection, it can be compromised.
5. Cryptographic Modules: Hardware components that may inadvertently expose keys or operations in trace outputs.",Confidentiality,"Unauthorized access to sensitive information, data leakage, compromise of cryptographic keys, reverse engineering of system behavior"
CWE-319,Cleartext Transmission of Sensitive Information,"This vulnerability arises when sensitive or security-critical data is transmitted in cleartext over communication channels that can be intercepted by unauthorized actors. In hardware contexts, this includes unencrypted data sent over interfaces like JTAG, UART, or internal buses, which can be exploited by attackers with physical access or through compromised components. Such exposures can lead to unauthorized access to confidential information, including passwords, encryption keys, and proprietary data.","1. Debug Interfaces (e.g., JTAG, UART): Interfaces that, if unencrypted, can expose sensitive data during transmission.
2. Internal Buses: Data lines within hardware that, without encryption, can be tapped to intercept sensitive information.
3. Memory Modules: Components that may transmit data in cleartext if not properly secured.
4. Configuration Registers: Registers that, if accessed over unencrypted channels, can reveal critical system settings.?
5. Firmware Update Mechanisms: Processes that, without encryption, can be exploited to inject malicious code or extract sensitive data.","Confidentiality, Integrity","Unauthorized access to sensitive information, data leakage, compromise of cryptographic keys, reverse engineering of system behavior"
CWE-1421,Exposure of Sensitive Information in Shared Microarchitectural Structures during Transient Execution,"Transient execution vulnerabilities, as described in CWE-1421, arise when speculative or out-of-order operations in modern processors transiently access architecturally restricted dataósuch as kernel memory, privileged system registers, or private buffersóbefore access control checks are resolved, potentially leaving microarchitectural traces observable via covert channels like CPU caches or fill buffers. These vulnerabilities undermine the expected isolation guarantees of ISA-enforced protections (e.g., virtual memory, privilege levels, trusted execution environments) by exploiting shared microarchitectural components across contexts such as SMT threads or privilege rings. Attackers can trigger faulting or mis-speculated code paths to transiently access sensitive data during execution, then infer that data using side channels such as timing differences or cache behavior. Examples include reading kernel memory before permission checks complete, accessing sibling thread fill buffers in SMT cores (as in MFBDS), or leaking privileged register values like TTBR0_EL1 during branch mispredictions. Such attacks threaten the confidentiality of system configurations, page tables, user data, and even hypervisor-level secrets, posing a critical risk to multi-tenant systems, cloud platforms, and any processor sharing microarchitectural resources without proper transient execution mitigations.","1. Kernel Memory Pages: Memory regions belonging to the OS kernel, which are normally inaccessible from user-mode processes, but may be transiently read due to speculative execution before privilege checks complete.
2. System Control Registers (e.g., TTBR0_EL1, CR3): Privileged CPU registers used for memory translation (page tables) or execution state; transient leaks of their values may expose memory layouts or critical system info.
3. Page Table Entries (PTEs) and Page Directory Structures: Memory mappings and permissions, which may be inferred to locate kernel modules, drivers, or sensitive mappings (important in attacks like Meltdown or Spectre V2).
4. Hypervisor or Virtual Machine Monitor (VMM) Data Structures: Internal data of hypervisors (e.g., guest-to-host mappings, VM control structures) that may be leaked by transient execution across VM boundaries in shared cores.
5. Simultaneous Multithreading (SMT) Fill Buffers: Shared microarchitectural fill buffers between sibling threads that can leak in-flight sensitive data (e.g., MFBDS-class attacks) during speculative or faulting operations.
6. Trusted Execution Environment (TEE) Enclaves (e.g., Intel SGX, ARM TrustZone): Data or cryptographic keys loaded into TEEs may become transiently visible through shared structures (e.g., L1 cache, fill buffers) due to mispredicted control flow or instruction reordering.
7. Cryptographic Keys in Co-processor Buffers: If a cryptographic accelerator shares microarchitectural resources with the CPU core, transient leaks may allow inference of AES or RSA key material during encryption/decryption.
8. System Management Mode (SMM) Memory Regions: Special memory areas used by SMM firmware (e.g., BIOS/UEFI handlers) may be exposed during speculative access under certain configurations.
9. Microcode Assist Buffers: Temporary buffers used by the processor during microcode assists (e.g., when handling VM exits or faults) can leak privileged values if transient execution bypasses isolation.
10. Instruction and Data Cache Lines from Other Security Domains: Caches shared across processes or privilege levels can transiently expose sensitive code or data via cache timing attacks (e.g., Flush+Reload or Prime+Probe).",Confidentiality,"Read privileged memory,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Bypass access control,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Leak system register values,
Extract page table information,
Access hypervisor memory,
Observe Trusted Execution Environment (TEE) data,
Read cryptographic keys,
Cross-thread data leakage,
Expose firmware state,
Break virtualization isolation,
Subvert address space isolation,
Defeat kernel/userspace boundaries,
Read transient CPU state,
Exploit microarchitectural side channels."
CWE-1423,Exposure of Sensitive Information caused by Shared Microarchitectural Predictor State that Influences Transient Execution,"In CWE-1423, attackers exploit shared microarchitectural predictor stateósuch as branch prediction tablesóacross hardware or privilege boundaries to influence transient execution in a victim context, potentially exposing sensitive data via side channels. When this predictor state is not properly isolated, a malicious process or thread (e.g., an SMT sibling or unprivileged user program) can train the predictor to steer a victimís transient execution toward attacker-chosen code paths that process sensitive values. Although these mispredicted instructions do not commit architecturally, they can leave observable microarchitectural traces (e.g., cache modifications) that leak confidential information. This threat undermines ISA-enforced isolation mechanisms like virtual memory, privilege rings, and execution domains by allowing attacker-controlled influence over speculative behavior. Real-world examples include Branch Target Injection (BTI), where predictors are poisoned cross-thread or cross-domain to induce speculative execution of gadgets in the victimís code, with leakage observed through covert channels such as Flush+Reload. This makes CWE-1423 particularly dangerous in multi-tenant systems, kernel-user transitions, or environments with SMT-enabled processors that share predictor structures across contexts.","1. Victim's Private Memory Contents: Confidential data (e.g., passwords, encryption keys, user secrets) residing in the victim processís memory that may be accessed transiently after branch misprediction.
2. Kernel-Mode Data: OS-level memory or registers that are normally inaccessible to user-mode code but may be speculatively accessed if predictor poisoning causes unintended kernel branches.
3  System Call Return Paths: Code paths executed immediately after a syscall transition (user ? kernel), where predictor training by user-mode code may influence kernel-mode speculation.
4. Branch Target Buffers (BTB): Microarchitectural structures that store branch targets and histories; shared BTBs may allow an attacker to influence victim control flow during speculative execution.
5. Indirect Branch Gadget Locations in Victim Code: Code sequences (e.g., in ntdll.dll, libc, or kernel drivers) that contain attacker-exploitable gadgetsósuch as arithmetic and memory load instructionsóused as transient gadgets.
6. Registers Influencing Memory Access (e.g., edi, ebx): CPU registers in the victim process that may be partially attacker-controlled and used in addressing memory during speculative execution after predictor poisoning.
7. Virtual Machine Monitor (VMM) or Hypervisor Metadata: Hypervisor-resident memory (e.g., EPT mappings, VMCS structures) potentially exposed when shared predictors allow guest VMs to poison control flow across privilege domains.
8. Trusted Execution Environment (TEE) Code Paths: Secure code branches in TEE (e.g., Intel SGX, ARM TrustZone) that may be speculatively influenced via poisoned predictors, leading to transient access of secure data.
9. Instruction Pointers of High-Privilege Routines Sensitive return addresses or branch destinations within privileged domains that may be speculatively redirected via BTI attacks.
10. Pre-fetched or Cached Sensitive Code/Data: Data transiently brought into cache due to mispredicted control flow, which becomes observable through timing side channels (e.g., Flush+Reload or Prime+Probe).",Confidentiality,"Read privileged memory,
Leak user process memory,
Expose kernel-mode data,
Observe speculative execution effects,
Trigger unintended transient code paths,
Bypass execution flow isolation,
Break virtual memory isolation,
Leak TEE-enclave data,
Infer hypervisor metadata,
Access speculative cache residues,
Manipulate branch predictor state,
Influence control flow speculatively,
Exploit side-channel timing discrepancies,
Subvert user-kernel transition integrity."
